// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nsm.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "nsm.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace nsm {

namespace {

const ::google::protobuf::Descriptor* NewGeneration_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NewGeneration_reflection_ = NULL;
const ::google::protobuf::Descriptor* Attotime_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Attotime_reflection_ = NULL;
const ::google::protobuf::Descriptor* AnalogPort_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AnalogPort_reflection_ = NULL;
const ::google::protobuf::Descriptor* InputPort_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InputPort_reflection_ = NULL;
const ::google::protobuf::Descriptor* InputState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InputState_reflection_ = NULL;
const ::google::protobuf::Descriptor* PeerInputData_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PeerInputData_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* PeerInputData_PeerInputType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* PeerInputDataList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PeerInputDataList_reflection_ = NULL;
const ::google::protobuf::Descriptor* InitialSync_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InitialSync_reflection_ = NULL;
const ::google::protobuf::Descriptor* SyncBlock_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SyncBlock_reflection_ = NULL;
const ::google::protobuf::Descriptor* Sync_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Sync_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_nsm_2eproto() {
  protobuf_AddDesc_nsm_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "nsm.proto");
  GOOGLE_CHECK(file != NULL);
  NewGeneration_descriptor_ = file->message_type(0);
  static const int NewGeneration_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewGeneration, generation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewGeneration, statefile_),
  };
  NewGeneration_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NewGeneration_descriptor_,
      NewGeneration::default_instance_,
      NewGeneration_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewGeneration, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewGeneration, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NewGeneration));
  Attotime_descriptor_ = file->message_type(1);
  static const int Attotime_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attotime, seconds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attotime, attoseconds_),
  };
  Attotime_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Attotime_descriptor_,
      Attotime::default_instance_,
      Attotime_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attotime, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attotime, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Attotime));
  AnalogPort_descriptor_ = file->message_type(2);
  static const int AnalogPort_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AnalogPort, accum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AnalogPort, previous_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AnalogPort, sensitivity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AnalogPort, reverse_),
  };
  AnalogPort_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AnalogPort_descriptor_,
      AnalogPort::default_instance_,
      AnalogPort_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AnalogPort, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AnalogPort, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AnalogPort));
  InputPort_descriptor_ = file->message_type(3);
  static const int InputPort_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InputPort, defvalue_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InputPort, digital_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InputPort, analogports_),
  };
  InputPort_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InputPort_descriptor_,
      InputPort::default_instance_,
      InputPort_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InputPort, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InputPort, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InputPort));
  InputState_descriptor_ = file->message_type(4);
  static const int InputState_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InputState, ports_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InputState, players_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InputState, framecount_),
  };
  InputState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InputState_descriptor_,
      InputState::default_instance_,
      InputState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InputState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InputState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InputState));
  PeerInputData_descriptor_ = file->message_type(5);
  static const int PeerInputData_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PeerInputData, counter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PeerInputData, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PeerInputData, inputtype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PeerInputData, inputstate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PeerInputData, inputbuffer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PeerInputData, generation_),
  };
  PeerInputData_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PeerInputData_descriptor_,
      PeerInputData::default_instance_,
      PeerInputData_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PeerInputData, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PeerInputData, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PeerInputData));
  PeerInputData_PeerInputType_descriptor_ = PeerInputData_descriptor_->enum_type(0);
  PeerInputDataList_descriptor_ = file->message_type(6);
  static const int PeerInputDataList_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PeerInputDataList, input_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PeerInputDataList, peer_id_),
  };
  PeerInputDataList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PeerInputDataList_descriptor_,
      PeerInputDataList::default_instance_,
      PeerInputDataList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PeerInputDataList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PeerInputDataList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PeerInputDataList));
  InitialSync_descriptor_ = file->message_type(7);
  static const int InitialSync_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitialSync, checksum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitialSync, initial_block_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitialSync, peer_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitialSync, nvram_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitialSync, generation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitialSync, global_time_),
  };
  InitialSync_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      InitialSync_descriptor_,
      InitialSync::default_instance_,
      InitialSync_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitialSync, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InitialSync, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(InitialSync));
  SyncBlock_descriptor_ = file->message_type(8);
  static const int SyncBlock_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SyncBlock, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SyncBlock, data_),
  };
  SyncBlock_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SyncBlock_descriptor_,
      SyncBlock::default_instance_,
      SyncBlock_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SyncBlock, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SyncBlock, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SyncBlock));
  Sync_descriptor_ = file->message_type(9);
  static const int Sync_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sync, block_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sync, global_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sync, generation_),
  };
  Sync_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Sync_descriptor_,
      Sync::default_instance_,
      Sync_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sync, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Sync, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Sync));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_nsm_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NewGeneration_descriptor_, &NewGeneration::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Attotime_descriptor_, &Attotime::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AnalogPort_descriptor_, &AnalogPort::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InputPort_descriptor_, &InputPort::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InputState_descriptor_, &InputState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PeerInputData_descriptor_, &PeerInputData::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PeerInputDataList_descriptor_, &PeerInputDataList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    InitialSync_descriptor_, &InitialSync::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SyncBlock_descriptor_, &SyncBlock::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Sync_descriptor_, &Sync::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_nsm_2eproto() {
  delete NewGeneration::default_instance_;
  delete NewGeneration_reflection_;
  delete Attotime::default_instance_;
  delete Attotime_reflection_;
  delete AnalogPort::default_instance_;
  delete AnalogPort_reflection_;
  delete InputPort::default_instance_;
  delete InputPort_reflection_;
  delete InputState::default_instance_;
  delete InputState_reflection_;
  delete PeerInputData::default_instance_;
  delete PeerInputData_reflection_;
  delete PeerInputDataList::default_instance_;
  delete PeerInputDataList_reflection_;
  delete InitialSync::default_instance_;
  delete InitialSync_reflection_;
  delete SyncBlock::default_instance_;
  delete SyncBlock_reflection_;
  delete Sync::default_instance_;
  delete Sync_reflection_;
}

void protobuf_AddDesc_nsm_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\tnsm.proto\022\003nsm\"6\n\rNewGeneration\022\022\n\ngen"
    "eration\030\001 \002(\005\022\021\n\tstateFile\030\002 \003(\014\"6\n\010Atto"
    "time\022\022\n\007seconds\030\001 \002(\005:\0010\022\026\n\013attoseconds\030"
    "\002 \002(\003:\0010\"S\n\nAnalogPort\022\r\n\005accum\030\001 \002(\005\022\020\n"
    "\010previous\030\002 \002(\005\022\023\n\013sensitivity\030\003 \002(\005\022\017\n\007"
    "reverse\030\004 \002(\010\"T\n\tInputPort\022\020\n\010defvalue\030\001"
    " \002(\r\022\017\n\007digital\030\002 \002(\r\022$\n\013analogPorts\030\003 \003"
    "(\0132\017.nsm.AnalogPort\"T\n\nInputState\022\035\n\005por"
    "ts\030\001 \003(\0132\016.nsm.InputPort\022\023\n\007players\030\002 \003("
    "\005B\002\020\001\022\022\n\nframecount\030\003 \002(\003\"\367\001\n\rPeerInputD"
    "ata\022\017\n\007counter\030\001 \002(\005\022\033\n\004time\030\002 \002(\0132\r.nsm"
    ".Attotime\0223\n\tinputType\030\003 \002(\0162 .nsm.PeerI"
    "nputData.PeerInputType\022#\n\ninputState\030\004 \001"
    "(\0132\017.nsm.InputState\022\023\n\013inputBuffer\030\005 \001(\014"
    "\022\022\n\ngeneration\030\006 \002(\005\"5\n\rPeerInputType\022\t\n"
    "\005INPUT\020\000\022\010\n\004CHAT\020\001\022\017\n\013FORCE_VALUE\020\002\"L\n\021P"
    "eerInputDataList\022&\n\ninput_data\030\001 \003(\0132\022.n"
    "sm.PeerInputData\022\017\n\007peer_id\030\002 \002(\005\"\250\001\n\013In"
    "itialSync\022\020\n\010checksum\030\001 \003(\r\022\025\n\rinitial_b"
    "lock\030\002 \003(\014\022)\n\tpeer_data\030\003 \003(\0132\026.nsm.Peer"
    "InputDataList\022\r\n\005nvram\030\004 \003(\014\022\022\n\ngenerati"
    "on\030\005 \002(\005\022\"\n\013global_time\030\006 \002(\0132\r.nsm.Atto"
    "time\"(\n\tSyncBlock\022\r\n\005index\030\001 \002(\005\022\014\n\004data"
    "\030\002 \002(\014\"]\n\004Sync\022\035\n\005block\030\001 \003(\0132\016.nsm.Sync"
    "Block\022\"\n\013global_time\030\002 \002(\0132\r.nsm.Attotim"
    "e\022\022\n\ngeneration\030\003 \002(\005", 1021);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "nsm.proto", &protobuf_RegisterTypes);
  NewGeneration::default_instance_ = new NewGeneration();
  Attotime::default_instance_ = new Attotime();
  AnalogPort::default_instance_ = new AnalogPort();
  InputPort::default_instance_ = new InputPort();
  InputState::default_instance_ = new InputState();
  PeerInputData::default_instance_ = new PeerInputData();
  PeerInputDataList::default_instance_ = new PeerInputDataList();
  InitialSync::default_instance_ = new InitialSync();
  SyncBlock::default_instance_ = new SyncBlock();
  Sync::default_instance_ = new Sync();
  NewGeneration::default_instance_->InitAsDefaultInstance();
  Attotime::default_instance_->InitAsDefaultInstance();
  AnalogPort::default_instance_->InitAsDefaultInstance();
  InputPort::default_instance_->InitAsDefaultInstance();
  InputState::default_instance_->InitAsDefaultInstance();
  PeerInputData::default_instance_->InitAsDefaultInstance();
  PeerInputDataList::default_instance_->InitAsDefaultInstance();
  InitialSync::default_instance_->InitAsDefaultInstance();
  SyncBlock::default_instance_->InitAsDefaultInstance();
  Sync::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_nsm_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_nsm_2eproto {
  StaticDescriptorInitializer_nsm_2eproto() {
    protobuf_AddDesc_nsm_2eproto();
  }
} static_descriptor_initializer_nsm_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int NewGeneration::kGenerationFieldNumber;
const int NewGeneration::kStateFileFieldNumber;
#endif  // !_MSC_VER

NewGeneration::NewGeneration()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:nsm.NewGeneration)
}

void NewGeneration::InitAsDefaultInstance() {
}

NewGeneration::NewGeneration(const NewGeneration& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:nsm.NewGeneration)
}

void NewGeneration::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  generation_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NewGeneration::~NewGeneration() {
  // @@protoc_insertion_point(destructor:nsm.NewGeneration)
  SharedDtor();
}

void NewGeneration::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NewGeneration::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NewGeneration::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NewGeneration_descriptor_;
}

const NewGeneration& NewGeneration::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_nsm_2eproto();
  return *default_instance_;
}

NewGeneration* NewGeneration::default_instance_ = NULL;

NewGeneration* NewGeneration::New() const {
  return new NewGeneration;
}

void NewGeneration::Clear() {
  generation_ = 0;
  statefile_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NewGeneration::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:nsm.NewGeneration)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 generation = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &generation_)));
          set_has_generation();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_stateFile;
        break;
      }

      // repeated bytes stateFile = 2;
      case 2: {
        if (tag == 18) {
         parse_stateFile:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_statefile()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_stateFile;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:nsm.NewGeneration)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:nsm.NewGeneration)
  return false;
#undef DO_
}

void NewGeneration::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:nsm.NewGeneration)
  // required int32 generation = 1;
  if (has_generation()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->generation(), output);
  }

  // repeated bytes stateFile = 2;
  for (int i = 0; i < this->statefile_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->statefile(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:nsm.NewGeneration)
}

::google::protobuf::uint8* NewGeneration::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:nsm.NewGeneration)
  // required int32 generation = 1;
  if (has_generation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->generation(), target);
  }

  // repeated bytes stateFile = 2;
  for (int i = 0; i < this->statefile_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(2, this->statefile(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nsm.NewGeneration)
  return target;
}

int NewGeneration::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 generation = 1;
    if (has_generation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->generation());
    }

  }
  // repeated bytes stateFile = 2;
  total_size += 1 * this->statefile_size();
  for (int i = 0; i < this->statefile_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->statefile(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NewGeneration::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NewGeneration* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NewGeneration*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NewGeneration::MergeFrom(const NewGeneration& from) {
  GOOGLE_CHECK_NE(&from, this);
  statefile_.MergeFrom(from.statefile_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_generation()) {
      set_generation(from.generation());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NewGeneration::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NewGeneration::CopyFrom(const NewGeneration& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewGeneration::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void NewGeneration::Swap(NewGeneration* other) {
  if (other != this) {
    std::swap(generation_, other->generation_);
    statefile_.Swap(&other->statefile_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NewGeneration::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NewGeneration_descriptor_;
  metadata.reflection = NewGeneration_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Attotime::kSecondsFieldNumber;
const int Attotime::kAttosecondsFieldNumber;
#endif  // !_MSC_VER

Attotime::Attotime()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:nsm.Attotime)
}

void Attotime::InitAsDefaultInstance() {
}

Attotime::Attotime(const Attotime& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:nsm.Attotime)
}

void Attotime::SharedCtor() {
  _cached_size_ = 0;
  seconds_ = 0;
  attoseconds_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Attotime::~Attotime() {
  // @@protoc_insertion_point(destructor:nsm.Attotime)
  SharedDtor();
}

void Attotime::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Attotime::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Attotime::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Attotime_descriptor_;
}

const Attotime& Attotime::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_nsm_2eproto();
  return *default_instance_;
}

Attotime* Attotime::default_instance_ = NULL;

Attotime* Attotime::New() const {
  return new Attotime;
}

void Attotime::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Attotime*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(attoseconds_, seconds_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Attotime::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:nsm.Attotime)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 seconds = 1 [default = 0];
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seconds_)));
          set_has_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_attoseconds;
        break;
      }

      // required int64 attoseconds = 2 [default = 0];
      case 2: {
        if (tag == 16) {
         parse_attoseconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &attoseconds_)));
          set_has_attoseconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:nsm.Attotime)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:nsm.Attotime)
  return false;
#undef DO_
}

void Attotime::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:nsm.Attotime)
  // required int32 seconds = 1 [default = 0];
  if (has_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->seconds(), output);
  }

  // required int64 attoseconds = 2 [default = 0];
  if (has_attoseconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->attoseconds(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:nsm.Attotime)
}

::google::protobuf::uint8* Attotime::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:nsm.Attotime)
  // required int32 seconds = 1 [default = 0];
  if (has_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->seconds(), target);
  }

  // required int64 attoseconds = 2 [default = 0];
  if (has_attoseconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->attoseconds(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nsm.Attotime)
  return target;
}

int Attotime::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 seconds = 1 [default = 0];
    if (has_seconds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->seconds());
    }

    // required int64 attoseconds = 2 [default = 0];
    if (has_attoseconds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->attoseconds());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Attotime::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Attotime* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Attotime*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Attotime::MergeFrom(const Attotime& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_seconds()) {
      set_seconds(from.seconds());
    }
    if (from.has_attoseconds()) {
      set_attoseconds(from.attoseconds());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Attotime::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Attotime::CopyFrom(const Attotime& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Attotime::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Attotime::Swap(Attotime* other) {
  if (other != this) {
    std::swap(seconds_, other->seconds_);
    std::swap(attoseconds_, other->attoseconds_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Attotime::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Attotime_descriptor_;
  metadata.reflection = Attotime_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AnalogPort::kAccumFieldNumber;
const int AnalogPort::kPreviousFieldNumber;
const int AnalogPort::kSensitivityFieldNumber;
const int AnalogPort::kReverseFieldNumber;
#endif  // !_MSC_VER

AnalogPort::AnalogPort()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:nsm.AnalogPort)
}

void AnalogPort::InitAsDefaultInstance() {
}

AnalogPort::AnalogPort(const AnalogPort& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:nsm.AnalogPort)
}

void AnalogPort::SharedCtor() {
  _cached_size_ = 0;
  accum_ = 0;
  previous_ = 0;
  sensitivity_ = 0;
  reverse_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AnalogPort::~AnalogPort() {
  // @@protoc_insertion_point(destructor:nsm.AnalogPort)
  SharedDtor();
}

void AnalogPort::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AnalogPort::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AnalogPort::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AnalogPort_descriptor_;
}

const AnalogPort& AnalogPort::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_nsm_2eproto();
  return *default_instance_;
}

AnalogPort* AnalogPort::default_instance_ = NULL;

AnalogPort* AnalogPort::New() const {
  return new AnalogPort;
}

void AnalogPort::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<AnalogPort*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(accum_, reverse_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AnalogPort::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:nsm.AnalogPort)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 accum = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &accum_)));
          set_has_accum();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_previous;
        break;
      }

      // required int32 previous = 2;
      case 2: {
        if (tag == 16) {
         parse_previous:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &previous_)));
          set_has_previous();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_sensitivity;
        break;
      }

      // required int32 sensitivity = 3;
      case 3: {
        if (tag == 24) {
         parse_sensitivity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sensitivity_)));
          set_has_sensitivity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_reverse;
        break;
      }

      // required bool reverse = 4;
      case 4: {
        if (tag == 32) {
         parse_reverse:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &reverse_)));
          set_has_reverse();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:nsm.AnalogPort)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:nsm.AnalogPort)
  return false;
#undef DO_
}

void AnalogPort::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:nsm.AnalogPort)
  // required int32 accum = 1;
  if (has_accum()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->accum(), output);
  }

  // required int32 previous = 2;
  if (has_previous()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->previous(), output);
  }

  // required int32 sensitivity = 3;
  if (has_sensitivity()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->sensitivity(), output);
  }

  // required bool reverse = 4;
  if (has_reverse()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->reverse(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:nsm.AnalogPort)
}

::google::protobuf::uint8* AnalogPort::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:nsm.AnalogPort)
  // required int32 accum = 1;
  if (has_accum()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->accum(), target);
  }

  // required int32 previous = 2;
  if (has_previous()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->previous(), target);
  }

  // required int32 sensitivity = 3;
  if (has_sensitivity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->sensitivity(), target);
  }

  // required bool reverse = 4;
  if (has_reverse()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->reverse(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nsm.AnalogPort)
  return target;
}

int AnalogPort::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 accum = 1;
    if (has_accum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->accum());
    }

    // required int32 previous = 2;
    if (has_previous()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->previous());
    }

    // required int32 sensitivity = 3;
    if (has_sensitivity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sensitivity());
    }

    // required bool reverse = 4;
    if (has_reverse()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AnalogPort::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AnalogPort* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AnalogPort*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AnalogPort::MergeFrom(const AnalogPort& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_accum()) {
      set_accum(from.accum());
    }
    if (from.has_previous()) {
      set_previous(from.previous());
    }
    if (from.has_sensitivity()) {
      set_sensitivity(from.sensitivity());
    }
    if (from.has_reverse()) {
      set_reverse(from.reverse());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AnalogPort::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AnalogPort::CopyFrom(const AnalogPort& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AnalogPort::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void AnalogPort::Swap(AnalogPort* other) {
  if (other != this) {
    std::swap(accum_, other->accum_);
    std::swap(previous_, other->previous_);
    std::swap(sensitivity_, other->sensitivity_);
    std::swap(reverse_, other->reverse_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AnalogPort::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AnalogPort_descriptor_;
  metadata.reflection = AnalogPort_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InputPort::kDefvalueFieldNumber;
const int InputPort::kDigitalFieldNumber;
const int InputPort::kAnalogPortsFieldNumber;
#endif  // !_MSC_VER

InputPort::InputPort()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:nsm.InputPort)
}

void InputPort::InitAsDefaultInstance() {
}

InputPort::InputPort(const InputPort& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:nsm.InputPort)
}

void InputPort::SharedCtor() {
  _cached_size_ = 0;
  defvalue_ = 0u;
  digital_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InputPort::~InputPort() {
  // @@protoc_insertion_point(destructor:nsm.InputPort)
  SharedDtor();
}

void InputPort::SharedDtor() {
  if (this != default_instance_) {
  }
}

void InputPort::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InputPort::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InputPort_descriptor_;
}

const InputPort& InputPort::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_nsm_2eproto();
  return *default_instance_;
}

InputPort* InputPort::default_instance_ = NULL;

InputPort* InputPort::New() const {
  return new InputPort;
}

void InputPort::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<InputPort*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(defvalue_, digital_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  analogports_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InputPort::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:nsm.InputPort)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 defvalue = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &defvalue_)));
          set_has_defvalue();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_digital;
        break;
      }

      // required uint32 digital = 2;
      case 2: {
        if (tag == 16) {
         parse_digital:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &digital_)));
          set_has_digital();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_analogPorts;
        break;
      }

      // repeated .nsm.AnalogPort analogPorts = 3;
      case 3: {
        if (tag == 26) {
         parse_analogPorts:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_analogports()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_analogPorts;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:nsm.InputPort)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:nsm.InputPort)
  return false;
#undef DO_
}

void InputPort::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:nsm.InputPort)
  // required uint32 defvalue = 1;
  if (has_defvalue()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->defvalue(), output);
  }

  // required uint32 digital = 2;
  if (has_digital()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->digital(), output);
  }

  // repeated .nsm.AnalogPort analogPorts = 3;
  for (int i = 0; i < this->analogports_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->analogports(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:nsm.InputPort)
}

::google::protobuf::uint8* InputPort::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:nsm.InputPort)
  // required uint32 defvalue = 1;
  if (has_defvalue()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->defvalue(), target);
  }

  // required uint32 digital = 2;
  if (has_digital()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->digital(), target);
  }

  // repeated .nsm.AnalogPort analogPorts = 3;
  for (int i = 0; i < this->analogports_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->analogports(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nsm.InputPort)
  return target;
}

int InputPort::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 defvalue = 1;
    if (has_defvalue()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->defvalue());
    }

    // required uint32 digital = 2;
    if (has_digital()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->digital());
    }

  }
  // repeated .nsm.AnalogPort analogPorts = 3;
  total_size += 1 * this->analogports_size();
  for (int i = 0; i < this->analogports_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->analogports(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InputPort::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InputPort* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InputPort*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InputPort::MergeFrom(const InputPort& from) {
  GOOGLE_CHECK_NE(&from, this);
  analogports_.MergeFrom(from.analogports_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_defvalue()) {
      set_defvalue(from.defvalue());
    }
    if (from.has_digital()) {
      set_digital(from.digital());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InputPort::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InputPort::CopyFrom(const InputPort& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InputPort::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->analogports())) return false;
  return true;
}

void InputPort::Swap(InputPort* other) {
  if (other != this) {
    std::swap(defvalue_, other->defvalue_);
    std::swap(digital_, other->digital_);
    analogports_.Swap(&other->analogports_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InputPort::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InputPort_descriptor_;
  metadata.reflection = InputPort_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InputState::kPortsFieldNumber;
const int InputState::kPlayersFieldNumber;
const int InputState::kFramecountFieldNumber;
#endif  // !_MSC_VER

InputState::InputState()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:nsm.InputState)
}

void InputState::InitAsDefaultInstance() {
}

InputState::InputState(const InputState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:nsm.InputState)
}

void InputState::SharedCtor() {
  _cached_size_ = 0;
  framecount_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InputState::~InputState() {
  // @@protoc_insertion_point(destructor:nsm.InputState)
  SharedDtor();
}

void InputState::SharedDtor() {
  if (this != default_instance_) {
  }
}

void InputState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InputState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InputState_descriptor_;
}

const InputState& InputState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_nsm_2eproto();
  return *default_instance_;
}

InputState* InputState::default_instance_ = NULL;

InputState* InputState::New() const {
  return new InputState;
}

void InputState::Clear() {
  framecount_ = GOOGLE_LONGLONG(0);
  ports_.Clear();
  players_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InputState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:nsm.InputState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .nsm.InputPort ports = 1;
      case 1: {
        if (tag == 10) {
         parse_ports:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_ports()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_ports;
        if (input->ExpectTag(18)) goto parse_players;
        break;
      }

      // repeated int32 players = 2 [packed = true];
      case 2: {
        if (tag == 18) {
         parse_players:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_players())));
        } else if (tag == 16) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 18, input, this->mutable_players())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_framecount;
        break;
      }

      // required int64 framecount = 3;
      case 3: {
        if (tag == 24) {
         parse_framecount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &framecount_)));
          set_has_framecount();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:nsm.InputState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:nsm.InputState)
  return false;
#undef DO_
}

void InputState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:nsm.InputState)
  // repeated .nsm.InputPort ports = 1;
  for (int i = 0; i < this->ports_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->ports(i), output);
  }

  // repeated int32 players = 2 [packed = true];
  if (this->players_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(2, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_players_cached_byte_size_);
  }
  for (int i = 0; i < this->players_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32NoTag(
      this->players(i), output);
  }

  // required int64 framecount = 3;
  if (has_framecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->framecount(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:nsm.InputState)
}

::google::protobuf::uint8* InputState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:nsm.InputState)
  // repeated .nsm.InputPort ports = 1;
  for (int i = 0; i < this->ports_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->ports(i), target);
  }

  // repeated int32 players = 2 [packed = true];
  if (this->players_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      2,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _players_cached_byte_size_, target);
  }
  for (int i = 0; i < this->players_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32NoTagToArray(this->players(i), target);
  }

  // required int64 framecount = 3;
  if (has_framecount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->framecount(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nsm.InputState)
  return target;
}

int InputState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // required int64 framecount = 3;
    if (has_framecount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->framecount());
    }

  }
  // repeated .nsm.InputPort ports = 1;
  total_size += 1 * this->ports_size();
  for (int i = 0; i < this->ports_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ports(i));
  }

  // repeated int32 players = 2 [packed = true];
  {
    int data_size = 0;
    for (int i = 0; i < this->players_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->players(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _players_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InputState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InputState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InputState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InputState::MergeFrom(const InputState& from) {
  GOOGLE_CHECK_NE(&from, this);
  ports_.MergeFrom(from.ports_);
  players_.MergeFrom(from.players_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_framecount()) {
      set_framecount(from.framecount());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InputState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InputState::CopyFrom(const InputState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InputState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->ports())) return false;
  return true;
}

void InputState::Swap(InputState* other) {
  if (other != this) {
    ports_.Swap(&other->ports_);
    players_.Swap(&other->players_);
    std::swap(framecount_, other->framecount_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InputState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InputState_descriptor_;
  metadata.reflection = InputState_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* PeerInputData_PeerInputType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PeerInputData_PeerInputType_descriptor_;
}
bool PeerInputData_PeerInputType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const PeerInputData_PeerInputType PeerInputData::INPUT;
const PeerInputData_PeerInputType PeerInputData::CHAT;
const PeerInputData_PeerInputType PeerInputData::FORCE_VALUE;
const PeerInputData_PeerInputType PeerInputData::PeerInputType_MIN;
const PeerInputData_PeerInputType PeerInputData::PeerInputType_MAX;
const int PeerInputData::PeerInputType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int PeerInputData::kCounterFieldNumber;
const int PeerInputData::kTimeFieldNumber;
const int PeerInputData::kInputTypeFieldNumber;
const int PeerInputData::kInputStateFieldNumber;
const int PeerInputData::kInputBufferFieldNumber;
const int PeerInputData::kGenerationFieldNumber;
#endif  // !_MSC_VER

PeerInputData::PeerInputData()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:nsm.PeerInputData)
}

void PeerInputData::InitAsDefaultInstance() {
  time_ = const_cast< ::nsm::Attotime*>(&::nsm::Attotime::default_instance());
  inputstate_ = const_cast< ::nsm::InputState*>(&::nsm::InputState::default_instance());
}

PeerInputData::PeerInputData(const PeerInputData& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:nsm.PeerInputData)
}

void PeerInputData::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  counter_ = 0;
  time_ = NULL;
  inputtype_ = 0;
  inputstate_ = NULL;
  inputbuffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  generation_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PeerInputData::~PeerInputData() {
  // @@protoc_insertion_point(destructor:nsm.PeerInputData)
  SharedDtor();
}

void PeerInputData::SharedDtor() {
  if (inputbuffer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete inputbuffer_;
  }
  if (this != default_instance_) {
    delete time_;
    delete inputstate_;
  }
}

void PeerInputData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PeerInputData::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PeerInputData_descriptor_;
}

const PeerInputData& PeerInputData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_nsm_2eproto();
  return *default_instance_;
}

PeerInputData* PeerInputData::default_instance_ = NULL;

PeerInputData* PeerInputData::New() const {
  return new PeerInputData;
}

void PeerInputData::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PeerInputData*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(counter_, inputtype_);
    if (has_time()) {
      if (time_ != NULL) time_->::nsm::Attotime::Clear();
    }
    if (has_inputstate()) {
      if (inputstate_ != NULL) inputstate_->::nsm::InputState::Clear();
    }
    if (has_inputbuffer()) {
      if (inputbuffer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        inputbuffer_->clear();
      }
    }
    generation_ = 0;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PeerInputData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:nsm.PeerInputData)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 counter = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &counter_)));
          set_has_counter();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_time;
        break;
      }

      // required .nsm.Attotime time = 2;
      case 2: {
        if (tag == 18) {
         parse_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_time()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_inputType;
        break;
      }

      // required .nsm.PeerInputData.PeerInputType inputType = 3;
      case 3: {
        if (tag == 24) {
         parse_inputType:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::nsm::PeerInputData_PeerInputType_IsValid(value)) {
            set_inputtype(static_cast< ::nsm::PeerInputData_PeerInputType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_inputState;
        break;
      }

      // optional .nsm.InputState inputState = 4;
      case 4: {
        if (tag == 34) {
         parse_inputState:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_inputstate()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_inputBuffer;
        break;
      }

      // optional bytes inputBuffer = 5;
      case 5: {
        if (tag == 42) {
         parse_inputBuffer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_inputbuffer()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_generation;
        break;
      }

      // required int32 generation = 6;
      case 6: {
        if (tag == 48) {
         parse_generation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &generation_)));
          set_has_generation();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:nsm.PeerInputData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:nsm.PeerInputData)
  return false;
#undef DO_
}

void PeerInputData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:nsm.PeerInputData)
  // required int32 counter = 1;
  if (has_counter()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->counter(), output);
  }

  // required .nsm.Attotime time = 2;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->time(), output);
  }

  // required .nsm.PeerInputData.PeerInputType inputType = 3;
  if (has_inputtype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->inputtype(), output);
  }

  // optional .nsm.InputState inputState = 4;
  if (has_inputstate()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->inputstate(), output);
  }

  // optional bytes inputBuffer = 5;
  if (has_inputbuffer()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->inputbuffer(), output);
  }

  // required int32 generation = 6;
  if (has_generation()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->generation(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:nsm.PeerInputData)
}

::google::protobuf::uint8* PeerInputData::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:nsm.PeerInputData)
  // required int32 counter = 1;
  if (has_counter()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->counter(), target);
  }

  // required .nsm.Attotime time = 2;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->time(), target);
  }

  // required .nsm.PeerInputData.PeerInputType inputType = 3;
  if (has_inputtype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->inputtype(), target);
  }

  // optional .nsm.InputState inputState = 4;
  if (has_inputstate()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->inputstate(), target);
  }

  // optional bytes inputBuffer = 5;
  if (has_inputbuffer()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        5, this->inputbuffer(), target);
  }

  // required int32 generation = 6;
  if (has_generation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->generation(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nsm.PeerInputData)
  return target;
}

int PeerInputData::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 counter = 1;
    if (has_counter()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->counter());
    }

    // required .nsm.Attotime time = 2;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->time());
    }

    // required .nsm.PeerInputData.PeerInputType inputType = 3;
    if (has_inputtype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->inputtype());
    }

    // optional .nsm.InputState inputState = 4;
    if (has_inputstate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->inputstate());
    }

    // optional bytes inputBuffer = 5;
    if (has_inputbuffer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->inputbuffer());
    }

    // required int32 generation = 6;
    if (has_generation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->generation());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PeerInputData::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PeerInputData* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PeerInputData*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PeerInputData::MergeFrom(const PeerInputData& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_counter()) {
      set_counter(from.counter());
    }
    if (from.has_time()) {
      mutable_time()->::nsm::Attotime::MergeFrom(from.time());
    }
    if (from.has_inputtype()) {
      set_inputtype(from.inputtype());
    }
    if (from.has_inputstate()) {
      mutable_inputstate()->::nsm::InputState::MergeFrom(from.inputstate());
    }
    if (from.has_inputbuffer()) {
      set_inputbuffer(from.inputbuffer());
    }
    if (from.has_generation()) {
      set_generation(from.generation());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PeerInputData::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PeerInputData::CopyFrom(const PeerInputData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PeerInputData::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000027) != 0x00000027) return false;

  if (has_time()) {
    if (!this->time().IsInitialized()) return false;
  }
  if (has_inputstate()) {
    if (!this->inputstate().IsInitialized()) return false;
  }
  return true;
}

void PeerInputData::Swap(PeerInputData* other) {
  if (other != this) {
    std::swap(counter_, other->counter_);
    std::swap(time_, other->time_);
    std::swap(inputtype_, other->inputtype_);
    std::swap(inputstate_, other->inputstate_);
    std::swap(inputbuffer_, other->inputbuffer_);
    std::swap(generation_, other->generation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PeerInputData::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PeerInputData_descriptor_;
  metadata.reflection = PeerInputData_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PeerInputDataList::kInputDataFieldNumber;
const int PeerInputDataList::kPeerIdFieldNumber;
#endif  // !_MSC_VER

PeerInputDataList::PeerInputDataList()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:nsm.PeerInputDataList)
}

void PeerInputDataList::InitAsDefaultInstance() {
}

PeerInputDataList::PeerInputDataList(const PeerInputDataList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:nsm.PeerInputDataList)
}

void PeerInputDataList::SharedCtor() {
  _cached_size_ = 0;
  peer_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PeerInputDataList::~PeerInputDataList() {
  // @@protoc_insertion_point(destructor:nsm.PeerInputDataList)
  SharedDtor();
}

void PeerInputDataList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PeerInputDataList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PeerInputDataList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PeerInputDataList_descriptor_;
}

const PeerInputDataList& PeerInputDataList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_nsm_2eproto();
  return *default_instance_;
}

PeerInputDataList* PeerInputDataList::default_instance_ = NULL;

PeerInputDataList* PeerInputDataList::New() const {
  return new PeerInputDataList;
}

void PeerInputDataList::Clear() {
  peer_id_ = 0;
  input_data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PeerInputDataList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:nsm.PeerInputDataList)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .nsm.PeerInputData input_data = 1;
      case 1: {
        if (tag == 10) {
         parse_input_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_input_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_input_data;
        if (input->ExpectTag(16)) goto parse_peer_id;
        break;
      }

      // required int32 peer_id = 2;
      case 2: {
        if (tag == 16) {
         parse_peer_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &peer_id_)));
          set_has_peer_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:nsm.PeerInputDataList)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:nsm.PeerInputDataList)
  return false;
#undef DO_
}

void PeerInputDataList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:nsm.PeerInputDataList)
  // repeated .nsm.PeerInputData input_data = 1;
  for (int i = 0; i < this->input_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->input_data(i), output);
  }

  // required int32 peer_id = 2;
  if (has_peer_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->peer_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:nsm.PeerInputDataList)
}

::google::protobuf::uint8* PeerInputDataList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:nsm.PeerInputDataList)
  // repeated .nsm.PeerInputData input_data = 1;
  for (int i = 0; i < this->input_data_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->input_data(i), target);
  }

  // required int32 peer_id = 2;
  if (has_peer_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->peer_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nsm.PeerInputDataList)
  return target;
}

int PeerInputDataList::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required int32 peer_id = 2;
    if (has_peer_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->peer_id());
    }

  }
  // repeated .nsm.PeerInputData input_data = 1;
  total_size += 1 * this->input_data_size();
  for (int i = 0; i < this->input_data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->input_data(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PeerInputDataList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PeerInputDataList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PeerInputDataList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PeerInputDataList::MergeFrom(const PeerInputDataList& from) {
  GOOGLE_CHECK_NE(&from, this);
  input_data_.MergeFrom(from.input_data_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_peer_id()) {
      set_peer_id(from.peer_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PeerInputDataList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PeerInputDataList::CopyFrom(const PeerInputDataList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PeerInputDataList::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->input_data())) return false;
  return true;
}

void PeerInputDataList::Swap(PeerInputDataList* other) {
  if (other != this) {
    input_data_.Swap(&other->input_data_);
    std::swap(peer_id_, other->peer_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PeerInputDataList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PeerInputDataList_descriptor_;
  metadata.reflection = PeerInputDataList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int InitialSync::kChecksumFieldNumber;
const int InitialSync::kInitialBlockFieldNumber;
const int InitialSync::kPeerDataFieldNumber;
const int InitialSync::kNvramFieldNumber;
const int InitialSync::kGenerationFieldNumber;
const int InitialSync::kGlobalTimeFieldNumber;
#endif  // !_MSC_VER

InitialSync::InitialSync()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:nsm.InitialSync)
}

void InitialSync::InitAsDefaultInstance() {
  global_time_ = const_cast< ::nsm::Attotime*>(&::nsm::Attotime::default_instance());
}

InitialSync::InitialSync(const InitialSync& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:nsm.InitialSync)
}

void InitialSync::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  generation_ = 0;
  global_time_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InitialSync::~InitialSync() {
  // @@protoc_insertion_point(destructor:nsm.InitialSync)
  SharedDtor();
}

void InitialSync::SharedDtor() {
  if (this != default_instance_) {
    delete global_time_;
  }
}

void InitialSync::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InitialSync::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InitialSync_descriptor_;
}

const InitialSync& InitialSync::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_nsm_2eproto();
  return *default_instance_;
}

InitialSync* InitialSync::default_instance_ = NULL;

InitialSync* InitialSync::New() const {
  return new InitialSync;
}

void InitialSync::Clear() {
  if (_has_bits_[0 / 32] & 48) {
    generation_ = 0;
    if (has_global_time()) {
      if (global_time_ != NULL) global_time_->::nsm::Attotime::Clear();
    }
  }
  checksum_.Clear();
  initial_block_.Clear();
  peer_data_.Clear();
  nvram_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool InitialSync::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:nsm.InitialSync)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 checksum = 1;
      case 1: {
        if (tag == 8) {
         parse_checksum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8, input, this->mutable_checksum())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_checksum())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_checksum;
        if (input->ExpectTag(18)) goto parse_initial_block;
        break;
      }

      // repeated bytes initial_block = 2;
      case 2: {
        if (tag == 18) {
         parse_initial_block:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_initial_block()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_initial_block;
        if (input->ExpectTag(26)) goto parse_peer_data;
        break;
      }

      // repeated .nsm.PeerInputDataList peer_data = 3;
      case 3: {
        if (tag == 26) {
         parse_peer_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_peer_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_peer_data;
        if (input->ExpectTag(34)) goto parse_nvram;
        break;
      }

      // repeated bytes nvram = 4;
      case 4: {
        if (tag == 34) {
         parse_nvram:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_nvram()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_nvram;
        if (input->ExpectTag(40)) goto parse_generation;
        break;
      }

      // required int32 generation = 5;
      case 5: {
        if (tag == 40) {
         parse_generation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &generation_)));
          set_has_generation();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_global_time;
        break;
      }

      // required .nsm.Attotime global_time = 6;
      case 6: {
        if (tag == 50) {
         parse_global_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_global_time()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:nsm.InitialSync)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:nsm.InitialSync)
  return false;
#undef DO_
}

void InitialSync::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:nsm.InitialSync)
  // repeated uint32 checksum = 1;
  for (int i = 0; i < this->checksum_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->checksum(i), output);
  }

  // repeated bytes initial_block = 2;
  for (int i = 0; i < this->initial_block_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      2, this->initial_block(i), output);
  }

  // repeated .nsm.PeerInputDataList peer_data = 3;
  for (int i = 0; i < this->peer_data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->peer_data(i), output);
  }

  // repeated bytes nvram = 4;
  for (int i = 0; i < this->nvram_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      4, this->nvram(i), output);
  }

  // required int32 generation = 5;
  if (has_generation()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->generation(), output);
  }

  // required .nsm.Attotime global_time = 6;
  if (has_global_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->global_time(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:nsm.InitialSync)
}

::google::protobuf::uint8* InitialSync::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:nsm.InitialSync)
  // repeated uint32 checksum = 1;
  for (int i = 0; i < this->checksum_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(1, this->checksum(i), target);
  }

  // repeated bytes initial_block = 2;
  for (int i = 0; i < this->initial_block_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(2, this->initial_block(i), target);
  }

  // repeated .nsm.PeerInputDataList peer_data = 3;
  for (int i = 0; i < this->peer_data_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->peer_data(i), target);
  }

  // repeated bytes nvram = 4;
  for (int i = 0; i < this->nvram_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(4, this->nvram(i), target);
  }

  // required int32 generation = 5;
  if (has_generation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->generation(), target);
  }

  // required .nsm.Attotime global_time = 6;
  if (has_global_time()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->global_time(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nsm.InitialSync)
  return target;
}

int InitialSync::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[4 / 32] & (0xffu << (4 % 32))) {
    // required int32 generation = 5;
    if (has_generation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->generation());
    }

    // required .nsm.Attotime global_time = 6;
    if (has_global_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->global_time());
    }

  }
  // repeated uint32 checksum = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->checksum_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->checksum(i));
    }
    total_size += 1 * this->checksum_size() + data_size;
  }

  // repeated bytes initial_block = 2;
  total_size += 1 * this->initial_block_size();
  for (int i = 0; i < this->initial_block_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->initial_block(i));
  }

  // repeated .nsm.PeerInputDataList peer_data = 3;
  total_size += 1 * this->peer_data_size();
  for (int i = 0; i < this->peer_data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->peer_data(i));
  }

  // repeated bytes nvram = 4;
  total_size += 1 * this->nvram_size();
  for (int i = 0; i < this->nvram_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->nvram(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InitialSync::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const InitialSync* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const InitialSync*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void InitialSync::MergeFrom(const InitialSync& from) {
  GOOGLE_CHECK_NE(&from, this);
  checksum_.MergeFrom(from.checksum_);
  initial_block_.MergeFrom(from.initial_block_);
  peer_data_.MergeFrom(from.peer_data_);
  nvram_.MergeFrom(from.nvram_);
  if (from._has_bits_[4 / 32] & (0xffu << (4 % 32))) {
    if (from.has_generation()) {
      set_generation(from.generation());
    }
    if (from.has_global_time()) {
      mutable_global_time()->::nsm::Attotime::MergeFrom(from.global_time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void InitialSync::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InitialSync::CopyFrom(const InitialSync& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitialSync::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000030) != 0x00000030) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->peer_data())) return false;
  if (has_global_time()) {
    if (!this->global_time().IsInitialized()) return false;
  }
  return true;
}

void InitialSync::Swap(InitialSync* other) {
  if (other != this) {
    checksum_.Swap(&other->checksum_);
    initial_block_.Swap(&other->initial_block_);
    peer_data_.Swap(&other->peer_data_);
    nvram_.Swap(&other->nvram_);
    std::swap(generation_, other->generation_);
    std::swap(global_time_, other->global_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata InitialSync::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InitialSync_descriptor_;
  metadata.reflection = InitialSync_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SyncBlock::kIndexFieldNumber;
const int SyncBlock::kDataFieldNumber;
#endif  // !_MSC_VER

SyncBlock::SyncBlock()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:nsm.SyncBlock)
}

void SyncBlock::InitAsDefaultInstance() {
}

SyncBlock::SyncBlock(const SyncBlock& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:nsm.SyncBlock)
}

void SyncBlock::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  index_ = 0;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SyncBlock::~SyncBlock() {
  // @@protoc_insertion_point(destructor:nsm.SyncBlock)
  SharedDtor();
}

void SyncBlock::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (this != default_instance_) {
  }
}

void SyncBlock::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SyncBlock::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SyncBlock_descriptor_;
}

const SyncBlock& SyncBlock::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_nsm_2eproto();
  return *default_instance_;
}

SyncBlock* SyncBlock::default_instance_ = NULL;

SyncBlock* SyncBlock::New() const {
  return new SyncBlock;
}

void SyncBlock::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    index_ = 0;
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SyncBlock::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:nsm.SyncBlock)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // required bytes data = 2;
      case 2: {
        if (tag == 18) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:nsm.SyncBlock)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:nsm.SyncBlock)
  return false;
#undef DO_
}

void SyncBlock::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:nsm.SyncBlock)
  // required int32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  // required bytes data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:nsm.SyncBlock)
}

::google::protobuf::uint8* SyncBlock::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:nsm.SyncBlock)
  // required int32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->index(), target);
  }

  // required bytes data = 2;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nsm.SyncBlock)
  return target;
}

int SyncBlock::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // required bytes data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SyncBlock::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SyncBlock* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SyncBlock*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SyncBlock::MergeFrom(const SyncBlock& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SyncBlock::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SyncBlock::CopyFrom(const SyncBlock& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SyncBlock::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void SyncBlock::Swap(SyncBlock* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SyncBlock::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SyncBlock_descriptor_;
  metadata.reflection = SyncBlock_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Sync::kBlockFieldNumber;
const int Sync::kGlobalTimeFieldNumber;
const int Sync::kGenerationFieldNumber;
#endif  // !_MSC_VER

Sync::Sync()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:nsm.Sync)
}

void Sync::InitAsDefaultInstance() {
  global_time_ = const_cast< ::nsm::Attotime*>(&::nsm::Attotime::default_instance());
}

Sync::Sync(const Sync& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:nsm.Sync)
}

void Sync::SharedCtor() {
  _cached_size_ = 0;
  global_time_ = NULL;
  generation_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Sync::~Sync() {
  // @@protoc_insertion_point(destructor:nsm.Sync)
  SharedDtor();
}

void Sync::SharedDtor() {
  if (this != default_instance_) {
    delete global_time_;
  }
}

void Sync::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Sync::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Sync_descriptor_;
}

const Sync& Sync::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_nsm_2eproto();
  return *default_instance_;
}

Sync* Sync::default_instance_ = NULL;

Sync* Sync::New() const {
  return new Sync;
}

void Sync::Clear() {
  if (_has_bits_[0 / 32] & 6) {
    if (has_global_time()) {
      if (global_time_ != NULL) global_time_->::nsm::Attotime::Clear();
    }
    generation_ = 0;
  }
  block_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Sync::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:nsm.Sync)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .nsm.SyncBlock block = 1;
      case 1: {
        if (tag == 10) {
         parse_block:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_block()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_block;
        if (input->ExpectTag(18)) goto parse_global_time;
        break;
      }

      // required .nsm.Attotime global_time = 2;
      case 2: {
        if (tag == 18) {
         parse_global_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_global_time()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_generation;
        break;
      }

      // required int32 generation = 3;
      case 3: {
        if (tag == 24) {
         parse_generation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &generation_)));
          set_has_generation();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:nsm.Sync)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:nsm.Sync)
  return false;
#undef DO_
}

void Sync::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:nsm.Sync)
  // repeated .nsm.SyncBlock block = 1;
  for (int i = 0; i < this->block_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->block(i), output);
  }

  // required .nsm.Attotime global_time = 2;
  if (has_global_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->global_time(), output);
  }

  // required int32 generation = 3;
  if (has_generation()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->generation(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:nsm.Sync)
}

::google::protobuf::uint8* Sync::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:nsm.Sync)
  // repeated .nsm.SyncBlock block = 1;
  for (int i = 0; i < this->block_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->block(i), target);
  }

  // required .nsm.Attotime global_time = 2;
  if (has_global_time()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->global_time(), target);
  }

  // required int32 generation = 3;
  if (has_generation()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->generation(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:nsm.Sync)
  return target;
}

int Sync::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required .nsm.Attotime global_time = 2;
    if (has_global_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->global_time());
    }

    // required int32 generation = 3;
    if (has_generation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->generation());
    }

  }
  // repeated .nsm.SyncBlock block = 1;
  total_size += 1 * this->block_size();
  for (int i = 0; i < this->block_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->block(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Sync::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Sync* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Sync*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Sync::MergeFrom(const Sync& from) {
  GOOGLE_CHECK_NE(&from, this);
  block_.MergeFrom(from.block_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_global_time()) {
      mutable_global_time()->::nsm::Attotime::MergeFrom(from.global_time());
    }
    if (from.has_generation()) {
      set_generation(from.generation());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Sync::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Sync::CopyFrom(const Sync& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sync::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->block())) return false;
  if (has_global_time()) {
    if (!this->global_time().IsInitialized()) return false;
  }
  return true;
}

void Sync::Swap(Sync* other) {
  if (other != this) {
    block_.Swap(&other->block_);
    std::swap(global_time_, other->global_time_);
    std::swap(generation_, other->generation_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Sync::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Sync_descriptor_;
  metadata.reflection = Sync_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace nsm

// @@protoc_insertion_point(global_scope)
