// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nsm.proto

#ifndef PROTOBUF_nsm_2eproto__INCLUDED
#define PROTOBUF_nsm_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace nsm {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_nsm_2eproto();
void protobuf_AssignDesc_nsm_2eproto();
void protobuf_ShutdownFile_nsm_2eproto();

class NewGeneration;
class Attotime;
class AnalogPort;
class InputPort;
class InputState;
class PeerInputData;
class PeerInputDataList;
class InitialSync;
class SyncBlock;
class Sync;

enum PeerInputData_PeerInputType {
  PeerInputData_PeerInputType_INPUT = 0,
  PeerInputData_PeerInputType_CHAT = 1,
  PeerInputData_PeerInputType_FORCE_VALUE = 2
};
bool PeerInputData_PeerInputType_IsValid(int value);
const PeerInputData_PeerInputType PeerInputData_PeerInputType_PeerInputType_MIN = PeerInputData_PeerInputType_INPUT;
const PeerInputData_PeerInputType PeerInputData_PeerInputType_PeerInputType_MAX = PeerInputData_PeerInputType_FORCE_VALUE;
const int PeerInputData_PeerInputType_PeerInputType_ARRAYSIZE = PeerInputData_PeerInputType_PeerInputType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PeerInputData_PeerInputType_descriptor();
inline const ::std::string& PeerInputData_PeerInputType_Name(PeerInputData_PeerInputType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PeerInputData_PeerInputType_descriptor(), value);
}
inline bool PeerInputData_PeerInputType_Parse(
    const ::std::string& name, PeerInputData_PeerInputType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PeerInputData_PeerInputType>(
    PeerInputData_PeerInputType_descriptor(), name, value);
}
// ===================================================================

class NewGeneration : public ::google::protobuf::Message {
 public:
  NewGeneration();
  virtual ~NewGeneration();

  NewGeneration(const NewGeneration& from);

  inline NewGeneration& operator=(const NewGeneration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewGeneration& default_instance();

  void Swap(NewGeneration* other);

  // implements Message ----------------------------------------------

  NewGeneration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewGeneration& from);
  void MergeFrom(const NewGeneration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 generation = 1;
  inline bool has_generation() const;
  inline void clear_generation();
  static const int kGenerationFieldNumber = 1;
  inline ::google::protobuf::int32 generation() const;
  inline void set_generation(::google::protobuf::int32 value);

  // repeated bytes stateFile = 2;
  inline int statefile_size() const;
  inline void clear_statefile();
  static const int kStateFileFieldNumber = 2;
  inline const ::std::string& statefile(int index) const;
  inline ::std::string* mutable_statefile(int index);
  inline void set_statefile(int index, const ::std::string& value);
  inline void set_statefile(int index, const char* value);
  inline void set_statefile(int index, const void* value, size_t size);
  inline ::std::string* add_statefile();
  inline void add_statefile(const ::std::string& value);
  inline void add_statefile(const char* value);
  inline void add_statefile(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& statefile() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_statefile();

  // @@protoc_insertion_point(class_scope:nsm.NewGeneration)
 private:
  inline void set_has_generation();
  inline void clear_has_generation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> statefile_;
  ::google::protobuf::int32 generation_;
  friend void  protobuf_AddDesc_nsm_2eproto();
  friend void protobuf_AssignDesc_nsm_2eproto();
  friend void protobuf_ShutdownFile_nsm_2eproto();

  void InitAsDefaultInstance();
  static NewGeneration* default_instance_;
};
// -------------------------------------------------------------------

class Attotime : public ::google::protobuf::Message {
 public:
  Attotime();
  virtual ~Attotime();

  Attotime(const Attotime& from);

  inline Attotime& operator=(const Attotime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Attotime& default_instance();

  void Swap(Attotime* other);

  // implements Message ----------------------------------------------

  Attotime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Attotime& from);
  void MergeFrom(const Attotime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 seconds = 1 [default = 0];
  inline bool has_seconds() const;
  inline void clear_seconds();
  static const int kSecondsFieldNumber = 1;
  inline ::google::protobuf::int32 seconds() const;
  inline void set_seconds(::google::protobuf::int32 value);

  // required int64 attoseconds = 2 [default = 0];
  inline bool has_attoseconds() const;
  inline void clear_attoseconds();
  static const int kAttosecondsFieldNumber = 2;
  inline ::google::protobuf::int64 attoseconds() const;
  inline void set_attoseconds(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:nsm.Attotime)
 private:
  inline void set_has_seconds();
  inline void clear_has_seconds();
  inline void set_has_attoseconds();
  inline void clear_has_attoseconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 attoseconds_;
  ::google::protobuf::int32 seconds_;
  friend void  protobuf_AddDesc_nsm_2eproto();
  friend void protobuf_AssignDesc_nsm_2eproto();
  friend void protobuf_ShutdownFile_nsm_2eproto();

  void InitAsDefaultInstance();
  static Attotime* default_instance_;
};
// -------------------------------------------------------------------

class AnalogPort : public ::google::protobuf::Message {
 public:
  AnalogPort();
  virtual ~AnalogPort();

  AnalogPort(const AnalogPort& from);

  inline AnalogPort& operator=(const AnalogPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalogPort& default_instance();

  void Swap(AnalogPort* other);

  // implements Message ----------------------------------------------

  AnalogPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AnalogPort& from);
  void MergeFrom(const AnalogPort& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 accum = 1;
  inline bool has_accum() const;
  inline void clear_accum();
  static const int kAccumFieldNumber = 1;
  inline ::google::protobuf::int32 accum() const;
  inline void set_accum(::google::protobuf::int32 value);

  // required int32 previous = 2;
  inline bool has_previous() const;
  inline void clear_previous();
  static const int kPreviousFieldNumber = 2;
  inline ::google::protobuf::int32 previous() const;
  inline void set_previous(::google::protobuf::int32 value);

  // required int32 sensitivity = 3;
  inline bool has_sensitivity() const;
  inline void clear_sensitivity();
  static const int kSensitivityFieldNumber = 3;
  inline ::google::protobuf::int32 sensitivity() const;
  inline void set_sensitivity(::google::protobuf::int32 value);

  // required bool reverse = 4;
  inline bool has_reverse() const;
  inline void clear_reverse();
  static const int kReverseFieldNumber = 4;
  inline bool reverse() const;
  inline void set_reverse(bool value);

  // @@protoc_insertion_point(class_scope:nsm.AnalogPort)
 private:
  inline void set_has_accum();
  inline void clear_has_accum();
  inline void set_has_previous();
  inline void clear_has_previous();
  inline void set_has_sensitivity();
  inline void clear_has_sensitivity();
  inline void set_has_reverse();
  inline void clear_has_reverse();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 accum_;
  ::google::protobuf::int32 previous_;
  ::google::protobuf::int32 sensitivity_;
  bool reverse_;
  friend void  protobuf_AddDesc_nsm_2eproto();
  friend void protobuf_AssignDesc_nsm_2eproto();
  friend void protobuf_ShutdownFile_nsm_2eproto();

  void InitAsDefaultInstance();
  static AnalogPort* default_instance_;
};
// -------------------------------------------------------------------

class InputPort : public ::google::protobuf::Message {
 public:
  InputPort();
  virtual ~InputPort();

  InputPort(const InputPort& from);

  inline InputPort& operator=(const InputPort& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InputPort& default_instance();

  void Swap(InputPort* other);

  // implements Message ----------------------------------------------

  InputPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InputPort& from);
  void MergeFrom(const InputPort& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 defvalue = 1;
  inline bool has_defvalue() const;
  inline void clear_defvalue();
  static const int kDefvalueFieldNumber = 1;
  inline ::google::protobuf::uint32 defvalue() const;
  inline void set_defvalue(::google::protobuf::uint32 value);

  // required uint32 digital = 2;
  inline bool has_digital() const;
  inline void clear_digital();
  static const int kDigitalFieldNumber = 2;
  inline ::google::protobuf::uint32 digital() const;
  inline void set_digital(::google::protobuf::uint32 value);

  // repeated .nsm.AnalogPort analogPorts = 3;
  inline int analogports_size() const;
  inline void clear_analogports();
  static const int kAnalogPortsFieldNumber = 3;
  inline const ::nsm::AnalogPort& analogports(int index) const;
  inline ::nsm::AnalogPort* mutable_analogports(int index);
  inline ::nsm::AnalogPort* add_analogports();
  inline const ::google::protobuf::RepeatedPtrField< ::nsm::AnalogPort >&
      analogports() const;
  inline ::google::protobuf::RepeatedPtrField< ::nsm::AnalogPort >*
      mutable_analogports();

  // @@protoc_insertion_point(class_scope:nsm.InputPort)
 private:
  inline void set_has_defvalue();
  inline void clear_has_defvalue();
  inline void set_has_digital();
  inline void clear_has_digital();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 defvalue_;
  ::google::protobuf::uint32 digital_;
  ::google::protobuf::RepeatedPtrField< ::nsm::AnalogPort > analogports_;
  friend void  protobuf_AddDesc_nsm_2eproto();
  friend void protobuf_AssignDesc_nsm_2eproto();
  friend void protobuf_ShutdownFile_nsm_2eproto();

  void InitAsDefaultInstance();
  static InputPort* default_instance_;
};
// -------------------------------------------------------------------

class InputState : public ::google::protobuf::Message {
 public:
  InputState();
  virtual ~InputState();

  InputState(const InputState& from);

  inline InputState& operator=(const InputState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InputState& default_instance();

  void Swap(InputState* other);

  // implements Message ----------------------------------------------

  InputState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InputState& from);
  void MergeFrom(const InputState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nsm.InputPort ports = 1;
  inline int ports_size() const;
  inline void clear_ports();
  static const int kPortsFieldNumber = 1;
  inline const ::nsm::InputPort& ports(int index) const;
  inline ::nsm::InputPort* mutable_ports(int index);
  inline ::nsm::InputPort* add_ports();
  inline const ::google::protobuf::RepeatedPtrField< ::nsm::InputPort >&
      ports() const;
  inline ::google::protobuf::RepeatedPtrField< ::nsm::InputPort >*
      mutable_ports();

  // repeated int32 players = 2 [packed = true];
  inline int players_size() const;
  inline void clear_players();
  static const int kPlayersFieldNumber = 2;
  inline ::google::protobuf::int32 players(int index) const;
  inline void set_players(int index, ::google::protobuf::int32 value);
  inline void add_players(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      players() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_players();

  // required int64 framecount = 3;
  inline bool has_framecount() const;
  inline void clear_framecount();
  static const int kFramecountFieldNumber = 3;
  inline ::google::protobuf::int64 framecount() const;
  inline void set_framecount(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:nsm.InputState)
 private:
  inline void set_has_framecount();
  inline void clear_has_framecount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::nsm::InputPort > ports_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > players_;
  mutable int _players_cached_byte_size_;
  ::google::protobuf::int64 framecount_;
  friend void  protobuf_AddDesc_nsm_2eproto();
  friend void protobuf_AssignDesc_nsm_2eproto();
  friend void protobuf_ShutdownFile_nsm_2eproto();

  void InitAsDefaultInstance();
  static InputState* default_instance_;
};
// -------------------------------------------------------------------

class PeerInputData : public ::google::protobuf::Message {
 public:
  PeerInputData();
  virtual ~PeerInputData();

  PeerInputData(const PeerInputData& from);

  inline PeerInputData& operator=(const PeerInputData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerInputData& default_instance();

  void Swap(PeerInputData* other);

  // implements Message ----------------------------------------------

  PeerInputData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PeerInputData& from);
  void MergeFrom(const PeerInputData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PeerInputData_PeerInputType PeerInputType;
  static const PeerInputType INPUT = PeerInputData_PeerInputType_INPUT;
  static const PeerInputType CHAT = PeerInputData_PeerInputType_CHAT;
  static const PeerInputType FORCE_VALUE = PeerInputData_PeerInputType_FORCE_VALUE;
  static inline bool PeerInputType_IsValid(int value) {
    return PeerInputData_PeerInputType_IsValid(value);
  }
  static const PeerInputType PeerInputType_MIN =
    PeerInputData_PeerInputType_PeerInputType_MIN;
  static const PeerInputType PeerInputType_MAX =
    PeerInputData_PeerInputType_PeerInputType_MAX;
  static const int PeerInputType_ARRAYSIZE =
    PeerInputData_PeerInputType_PeerInputType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PeerInputType_descriptor() {
    return PeerInputData_PeerInputType_descriptor();
  }
  static inline const ::std::string& PeerInputType_Name(PeerInputType value) {
    return PeerInputData_PeerInputType_Name(value);
  }
  static inline bool PeerInputType_Parse(const ::std::string& name,
      PeerInputType* value) {
    return PeerInputData_PeerInputType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 counter = 1;
  inline bool has_counter() const;
  inline void clear_counter();
  static const int kCounterFieldNumber = 1;
  inline ::google::protobuf::int32 counter() const;
  inline void set_counter(::google::protobuf::int32 value);

  // required .nsm.Attotime time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline const ::nsm::Attotime& time() const;
  inline ::nsm::Attotime* mutable_time();
  inline ::nsm::Attotime* release_time();
  inline void set_allocated_time(::nsm::Attotime* time);

  // required .nsm.PeerInputData.PeerInputType inputType = 3;
  inline bool has_inputtype() const;
  inline void clear_inputtype();
  static const int kInputTypeFieldNumber = 3;
  inline ::nsm::PeerInputData_PeerInputType inputtype() const;
  inline void set_inputtype(::nsm::PeerInputData_PeerInputType value);

  // optional .nsm.InputState inputState = 4;
  inline bool has_inputstate() const;
  inline void clear_inputstate();
  static const int kInputStateFieldNumber = 4;
  inline const ::nsm::InputState& inputstate() const;
  inline ::nsm::InputState* mutable_inputstate();
  inline ::nsm::InputState* release_inputstate();
  inline void set_allocated_inputstate(::nsm::InputState* inputstate);

  // optional bytes inputBuffer = 5;
  inline bool has_inputbuffer() const;
  inline void clear_inputbuffer();
  static const int kInputBufferFieldNumber = 5;
  inline const ::std::string& inputbuffer() const;
  inline void set_inputbuffer(const ::std::string& value);
  inline void set_inputbuffer(const char* value);
  inline void set_inputbuffer(const void* value, size_t size);
  inline ::std::string* mutable_inputbuffer();
  inline ::std::string* release_inputbuffer();
  inline void set_allocated_inputbuffer(::std::string* inputbuffer);

  // required int32 generation = 6;
  inline bool has_generation() const;
  inline void clear_generation();
  static const int kGenerationFieldNumber = 6;
  inline ::google::protobuf::int32 generation() const;
  inline void set_generation(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nsm.PeerInputData)
 private:
  inline void set_has_counter();
  inline void clear_has_counter();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_inputtype();
  inline void clear_has_inputtype();
  inline void set_has_inputstate();
  inline void clear_has_inputstate();
  inline void set_has_inputbuffer();
  inline void clear_has_inputbuffer();
  inline void set_has_generation();
  inline void clear_has_generation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::nsm::Attotime* time_;
  ::google::protobuf::int32 counter_;
  int inputtype_;
  ::nsm::InputState* inputstate_;
  ::std::string* inputbuffer_;
  ::google::protobuf::int32 generation_;
  friend void  protobuf_AddDesc_nsm_2eproto();
  friend void protobuf_AssignDesc_nsm_2eproto();
  friend void protobuf_ShutdownFile_nsm_2eproto();

  void InitAsDefaultInstance();
  static PeerInputData* default_instance_;
};
// -------------------------------------------------------------------

class PeerInputDataList : public ::google::protobuf::Message {
 public:
  PeerInputDataList();
  virtual ~PeerInputDataList();

  PeerInputDataList(const PeerInputDataList& from);

  inline PeerInputDataList& operator=(const PeerInputDataList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PeerInputDataList& default_instance();

  void Swap(PeerInputDataList* other);

  // implements Message ----------------------------------------------

  PeerInputDataList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PeerInputDataList& from);
  void MergeFrom(const PeerInputDataList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nsm.PeerInputData input_data = 1;
  inline int input_data_size() const;
  inline void clear_input_data();
  static const int kInputDataFieldNumber = 1;
  inline const ::nsm::PeerInputData& input_data(int index) const;
  inline ::nsm::PeerInputData* mutable_input_data(int index);
  inline ::nsm::PeerInputData* add_input_data();
  inline const ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputData >&
      input_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputData >*
      mutable_input_data();

  // required int32 peer_id = 2;
  inline bool has_peer_id() const;
  inline void clear_peer_id();
  static const int kPeerIdFieldNumber = 2;
  inline ::google::protobuf::int32 peer_id() const;
  inline void set_peer_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nsm.PeerInputDataList)
 private:
  inline void set_has_peer_id();
  inline void clear_has_peer_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputData > input_data_;
  ::google::protobuf::int32 peer_id_;
  friend void  protobuf_AddDesc_nsm_2eproto();
  friend void protobuf_AssignDesc_nsm_2eproto();
  friend void protobuf_ShutdownFile_nsm_2eproto();

  void InitAsDefaultInstance();
  static PeerInputDataList* default_instance_;
};
// -------------------------------------------------------------------

class InitialSync : public ::google::protobuf::Message {
 public:
  InitialSync();
  virtual ~InitialSync();

  InitialSync(const InitialSync& from);

  inline InitialSync& operator=(const InitialSync& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitialSync& default_instance();

  void Swap(InitialSync* other);

  // implements Message ----------------------------------------------

  InitialSync* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InitialSync& from);
  void MergeFrom(const InitialSync& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 checksum = 1;
  inline int checksum_size() const;
  inline void clear_checksum();
  static const int kChecksumFieldNumber = 1;
  inline ::google::protobuf::uint32 checksum(int index) const;
  inline void set_checksum(int index, ::google::protobuf::uint32 value);
  inline void add_checksum(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      checksum() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_checksum();

  // repeated bytes initial_block = 2;
  inline int initial_block_size() const;
  inline void clear_initial_block();
  static const int kInitialBlockFieldNumber = 2;
  inline const ::std::string& initial_block(int index) const;
  inline ::std::string* mutable_initial_block(int index);
  inline void set_initial_block(int index, const ::std::string& value);
  inline void set_initial_block(int index, const char* value);
  inline void set_initial_block(int index, const void* value, size_t size);
  inline ::std::string* add_initial_block();
  inline void add_initial_block(const ::std::string& value);
  inline void add_initial_block(const char* value);
  inline void add_initial_block(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& initial_block() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_initial_block();

  // repeated .nsm.PeerInputDataList peer_data = 3;
  inline int peer_data_size() const;
  inline void clear_peer_data();
  static const int kPeerDataFieldNumber = 3;
  inline const ::nsm::PeerInputDataList& peer_data(int index) const;
  inline ::nsm::PeerInputDataList* mutable_peer_data(int index);
  inline ::nsm::PeerInputDataList* add_peer_data();
  inline const ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputDataList >&
      peer_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputDataList >*
      mutable_peer_data();

  // repeated bytes nvram = 4;
  inline int nvram_size() const;
  inline void clear_nvram();
  static const int kNvramFieldNumber = 4;
  inline const ::std::string& nvram(int index) const;
  inline ::std::string* mutable_nvram(int index);
  inline void set_nvram(int index, const ::std::string& value);
  inline void set_nvram(int index, const char* value);
  inline void set_nvram(int index, const void* value, size_t size);
  inline ::std::string* add_nvram();
  inline void add_nvram(const ::std::string& value);
  inline void add_nvram(const char* value);
  inline void add_nvram(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& nvram() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_nvram();

  // required int32 generation = 5;
  inline bool has_generation() const;
  inline void clear_generation();
  static const int kGenerationFieldNumber = 5;
  inline ::google::protobuf::int32 generation() const;
  inline void set_generation(::google::protobuf::int32 value);

  // required .nsm.Attotime global_time = 6;
  inline bool has_global_time() const;
  inline void clear_global_time();
  static const int kGlobalTimeFieldNumber = 6;
  inline const ::nsm::Attotime& global_time() const;
  inline ::nsm::Attotime* mutable_global_time();
  inline ::nsm::Attotime* release_global_time();
  inline void set_allocated_global_time(::nsm::Attotime* global_time);

  // @@protoc_insertion_point(class_scope:nsm.InitialSync)
 private:
  inline void set_has_generation();
  inline void clear_has_generation();
  inline void set_has_global_time();
  inline void clear_has_global_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > checksum_;
  ::google::protobuf::RepeatedPtrField< ::std::string> initial_block_;
  ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputDataList > peer_data_;
  ::google::protobuf::RepeatedPtrField< ::std::string> nvram_;
  ::nsm::Attotime* global_time_;
  ::google::protobuf::int32 generation_;
  friend void  protobuf_AddDesc_nsm_2eproto();
  friend void protobuf_AssignDesc_nsm_2eproto();
  friend void protobuf_ShutdownFile_nsm_2eproto();

  void InitAsDefaultInstance();
  static InitialSync* default_instance_;
};
// -------------------------------------------------------------------

class SyncBlock : public ::google::protobuf::Message {
 public:
  SyncBlock();
  virtual ~SyncBlock();

  SyncBlock(const SyncBlock& from);

  inline SyncBlock& operator=(const SyncBlock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SyncBlock& default_instance();

  void Swap(SyncBlock* other);

  // implements Message ----------------------------------------------

  SyncBlock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SyncBlock& from);
  void MergeFrom(const SyncBlock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:nsm.SyncBlock)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* data_;
  ::google::protobuf::int32 index_;
  friend void  protobuf_AddDesc_nsm_2eproto();
  friend void protobuf_AssignDesc_nsm_2eproto();
  friend void protobuf_ShutdownFile_nsm_2eproto();

  void InitAsDefaultInstance();
  static SyncBlock* default_instance_;
};
// -------------------------------------------------------------------

class Sync : public ::google::protobuf::Message {
 public:
  Sync();
  virtual ~Sync();

  Sync(const Sync& from);

  inline Sync& operator=(const Sync& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sync& default_instance();

  void Swap(Sync* other);

  // implements Message ----------------------------------------------

  Sync* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sync& from);
  void MergeFrom(const Sync& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nsm.SyncBlock block = 1;
  inline int block_size() const;
  inline void clear_block();
  static const int kBlockFieldNumber = 1;
  inline const ::nsm::SyncBlock& block(int index) const;
  inline ::nsm::SyncBlock* mutable_block(int index);
  inline ::nsm::SyncBlock* add_block();
  inline const ::google::protobuf::RepeatedPtrField< ::nsm::SyncBlock >&
      block() const;
  inline ::google::protobuf::RepeatedPtrField< ::nsm::SyncBlock >*
      mutable_block();

  // required .nsm.Attotime global_time = 2;
  inline bool has_global_time() const;
  inline void clear_global_time();
  static const int kGlobalTimeFieldNumber = 2;
  inline const ::nsm::Attotime& global_time() const;
  inline ::nsm::Attotime* mutable_global_time();
  inline ::nsm::Attotime* release_global_time();
  inline void set_allocated_global_time(::nsm::Attotime* global_time);

  // required int32 generation = 3;
  inline bool has_generation() const;
  inline void clear_generation();
  static const int kGenerationFieldNumber = 3;
  inline ::google::protobuf::int32 generation() const;
  inline void set_generation(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nsm.Sync)
 private:
  inline void set_has_global_time();
  inline void clear_has_global_time();
  inline void set_has_generation();
  inline void clear_has_generation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::nsm::SyncBlock > block_;
  ::nsm::Attotime* global_time_;
  ::google::protobuf::int32 generation_;
  friend void  protobuf_AddDesc_nsm_2eproto();
  friend void protobuf_AssignDesc_nsm_2eproto();
  friend void protobuf_ShutdownFile_nsm_2eproto();

  void InitAsDefaultInstance();
  static Sync* default_instance_;
};
// ===================================================================


// ===================================================================

// NewGeneration

// required int32 generation = 1;
inline bool NewGeneration::has_generation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewGeneration::set_has_generation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewGeneration::clear_has_generation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewGeneration::clear_generation() {
  generation_ = 0;
  clear_has_generation();
}
inline ::google::protobuf::int32 NewGeneration::generation() const {
  // @@protoc_insertion_point(field_get:nsm.NewGeneration.generation)
  return generation_;
}
inline void NewGeneration::set_generation(::google::protobuf::int32 value) {
  set_has_generation();
  generation_ = value;
  // @@protoc_insertion_point(field_set:nsm.NewGeneration.generation)
}

// repeated bytes stateFile = 2;
inline int NewGeneration::statefile_size() const {
  return statefile_.size();
}
inline void NewGeneration::clear_statefile() {
  statefile_.Clear();
}
inline const ::std::string& NewGeneration::statefile(int index) const {
  // @@protoc_insertion_point(field_get:nsm.NewGeneration.stateFile)
  return statefile_.Get(index);
}
inline ::std::string* NewGeneration::mutable_statefile(int index) {
  // @@protoc_insertion_point(field_mutable:nsm.NewGeneration.stateFile)
  return statefile_.Mutable(index);
}
inline void NewGeneration::set_statefile(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nsm.NewGeneration.stateFile)
  statefile_.Mutable(index)->assign(value);
}
inline void NewGeneration::set_statefile(int index, const char* value) {
  statefile_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nsm.NewGeneration.stateFile)
}
inline void NewGeneration::set_statefile(int index, const void* value, size_t size) {
  statefile_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nsm.NewGeneration.stateFile)
}
inline ::std::string* NewGeneration::add_statefile() {
  return statefile_.Add();
}
inline void NewGeneration::add_statefile(const ::std::string& value) {
  statefile_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nsm.NewGeneration.stateFile)
}
inline void NewGeneration::add_statefile(const char* value) {
  statefile_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nsm.NewGeneration.stateFile)
}
inline void NewGeneration::add_statefile(const void* value, size_t size) {
  statefile_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nsm.NewGeneration.stateFile)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NewGeneration::statefile() const {
  // @@protoc_insertion_point(field_list:nsm.NewGeneration.stateFile)
  return statefile_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NewGeneration::mutable_statefile() {
  // @@protoc_insertion_point(field_mutable_list:nsm.NewGeneration.stateFile)
  return &statefile_;
}

// -------------------------------------------------------------------

// Attotime

// required int32 seconds = 1 [default = 0];
inline bool Attotime::has_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attotime::set_has_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attotime::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attotime::clear_seconds() {
  seconds_ = 0;
  clear_has_seconds();
}
inline ::google::protobuf::int32 Attotime::seconds() const {
  // @@protoc_insertion_point(field_get:nsm.Attotime.seconds)
  return seconds_;
}
inline void Attotime::set_seconds(::google::protobuf::int32 value) {
  set_has_seconds();
  seconds_ = value;
  // @@protoc_insertion_point(field_set:nsm.Attotime.seconds)
}

// required int64 attoseconds = 2 [default = 0];
inline bool Attotime::has_attoseconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Attotime::set_has_attoseconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Attotime::clear_has_attoseconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Attotime::clear_attoseconds() {
  attoseconds_ = GOOGLE_LONGLONG(0);
  clear_has_attoseconds();
}
inline ::google::protobuf::int64 Attotime::attoseconds() const {
  // @@protoc_insertion_point(field_get:nsm.Attotime.attoseconds)
  return attoseconds_;
}
inline void Attotime::set_attoseconds(::google::protobuf::int64 value) {
  set_has_attoseconds();
  attoseconds_ = value;
  // @@protoc_insertion_point(field_set:nsm.Attotime.attoseconds)
}

// -------------------------------------------------------------------

// AnalogPort

// required int32 accum = 1;
inline bool AnalogPort::has_accum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnalogPort::set_has_accum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnalogPort::clear_has_accum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnalogPort::clear_accum() {
  accum_ = 0;
  clear_has_accum();
}
inline ::google::protobuf::int32 AnalogPort::accum() const {
  // @@protoc_insertion_point(field_get:nsm.AnalogPort.accum)
  return accum_;
}
inline void AnalogPort::set_accum(::google::protobuf::int32 value) {
  set_has_accum();
  accum_ = value;
  // @@protoc_insertion_point(field_set:nsm.AnalogPort.accum)
}

// required int32 previous = 2;
inline bool AnalogPort::has_previous() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnalogPort::set_has_previous() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnalogPort::clear_has_previous() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnalogPort::clear_previous() {
  previous_ = 0;
  clear_has_previous();
}
inline ::google::protobuf::int32 AnalogPort::previous() const {
  // @@protoc_insertion_point(field_get:nsm.AnalogPort.previous)
  return previous_;
}
inline void AnalogPort::set_previous(::google::protobuf::int32 value) {
  set_has_previous();
  previous_ = value;
  // @@protoc_insertion_point(field_set:nsm.AnalogPort.previous)
}

// required int32 sensitivity = 3;
inline bool AnalogPort::has_sensitivity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnalogPort::set_has_sensitivity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnalogPort::clear_has_sensitivity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnalogPort::clear_sensitivity() {
  sensitivity_ = 0;
  clear_has_sensitivity();
}
inline ::google::protobuf::int32 AnalogPort::sensitivity() const {
  // @@protoc_insertion_point(field_get:nsm.AnalogPort.sensitivity)
  return sensitivity_;
}
inline void AnalogPort::set_sensitivity(::google::protobuf::int32 value) {
  set_has_sensitivity();
  sensitivity_ = value;
  // @@protoc_insertion_point(field_set:nsm.AnalogPort.sensitivity)
}

// required bool reverse = 4;
inline bool AnalogPort::has_reverse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnalogPort::set_has_reverse() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnalogPort::clear_has_reverse() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnalogPort::clear_reverse() {
  reverse_ = false;
  clear_has_reverse();
}
inline bool AnalogPort::reverse() const {
  // @@protoc_insertion_point(field_get:nsm.AnalogPort.reverse)
  return reverse_;
}
inline void AnalogPort::set_reverse(bool value) {
  set_has_reverse();
  reverse_ = value;
  // @@protoc_insertion_point(field_set:nsm.AnalogPort.reverse)
}

// -------------------------------------------------------------------

// InputPort

// required uint32 defvalue = 1;
inline bool InputPort::has_defvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InputPort::set_has_defvalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InputPort::clear_has_defvalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InputPort::clear_defvalue() {
  defvalue_ = 0u;
  clear_has_defvalue();
}
inline ::google::protobuf::uint32 InputPort::defvalue() const {
  // @@protoc_insertion_point(field_get:nsm.InputPort.defvalue)
  return defvalue_;
}
inline void InputPort::set_defvalue(::google::protobuf::uint32 value) {
  set_has_defvalue();
  defvalue_ = value;
  // @@protoc_insertion_point(field_set:nsm.InputPort.defvalue)
}

// required uint32 digital = 2;
inline bool InputPort::has_digital() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InputPort::set_has_digital() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InputPort::clear_has_digital() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InputPort::clear_digital() {
  digital_ = 0u;
  clear_has_digital();
}
inline ::google::protobuf::uint32 InputPort::digital() const {
  // @@protoc_insertion_point(field_get:nsm.InputPort.digital)
  return digital_;
}
inline void InputPort::set_digital(::google::protobuf::uint32 value) {
  set_has_digital();
  digital_ = value;
  // @@protoc_insertion_point(field_set:nsm.InputPort.digital)
}

// repeated .nsm.AnalogPort analogPorts = 3;
inline int InputPort::analogports_size() const {
  return analogports_.size();
}
inline void InputPort::clear_analogports() {
  analogports_.Clear();
}
inline const ::nsm::AnalogPort& InputPort::analogports(int index) const {
  // @@protoc_insertion_point(field_get:nsm.InputPort.analogPorts)
  return analogports_.Get(index);
}
inline ::nsm::AnalogPort* InputPort::mutable_analogports(int index) {
  // @@protoc_insertion_point(field_mutable:nsm.InputPort.analogPorts)
  return analogports_.Mutable(index);
}
inline ::nsm::AnalogPort* InputPort::add_analogports() {
  // @@protoc_insertion_point(field_add:nsm.InputPort.analogPorts)
  return analogports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nsm::AnalogPort >&
InputPort::analogports() const {
  // @@protoc_insertion_point(field_list:nsm.InputPort.analogPorts)
  return analogports_;
}
inline ::google::protobuf::RepeatedPtrField< ::nsm::AnalogPort >*
InputPort::mutable_analogports() {
  // @@protoc_insertion_point(field_mutable_list:nsm.InputPort.analogPorts)
  return &analogports_;
}

// -------------------------------------------------------------------

// InputState

// repeated .nsm.InputPort ports = 1;
inline int InputState::ports_size() const {
  return ports_.size();
}
inline void InputState::clear_ports() {
  ports_.Clear();
}
inline const ::nsm::InputPort& InputState::ports(int index) const {
  // @@protoc_insertion_point(field_get:nsm.InputState.ports)
  return ports_.Get(index);
}
inline ::nsm::InputPort* InputState::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:nsm.InputState.ports)
  return ports_.Mutable(index);
}
inline ::nsm::InputPort* InputState::add_ports() {
  // @@protoc_insertion_point(field_add:nsm.InputState.ports)
  return ports_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nsm::InputPort >&
InputState::ports() const {
  // @@protoc_insertion_point(field_list:nsm.InputState.ports)
  return ports_;
}
inline ::google::protobuf::RepeatedPtrField< ::nsm::InputPort >*
InputState::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:nsm.InputState.ports)
  return &ports_;
}

// repeated int32 players = 2 [packed = true];
inline int InputState::players_size() const {
  return players_.size();
}
inline void InputState::clear_players() {
  players_.Clear();
}
inline ::google::protobuf::int32 InputState::players(int index) const {
  // @@protoc_insertion_point(field_get:nsm.InputState.players)
  return players_.Get(index);
}
inline void InputState::set_players(int index, ::google::protobuf::int32 value) {
  players_.Set(index, value);
  // @@protoc_insertion_point(field_set:nsm.InputState.players)
}
inline void InputState::add_players(::google::protobuf::int32 value) {
  players_.Add(value);
  // @@protoc_insertion_point(field_add:nsm.InputState.players)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
InputState::players() const {
  // @@protoc_insertion_point(field_list:nsm.InputState.players)
  return players_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
InputState::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:nsm.InputState.players)
  return &players_;
}

// required int64 framecount = 3;
inline bool InputState::has_framecount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InputState::set_has_framecount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InputState::clear_has_framecount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InputState::clear_framecount() {
  framecount_ = GOOGLE_LONGLONG(0);
  clear_has_framecount();
}
inline ::google::protobuf::int64 InputState::framecount() const {
  // @@protoc_insertion_point(field_get:nsm.InputState.framecount)
  return framecount_;
}
inline void InputState::set_framecount(::google::protobuf::int64 value) {
  set_has_framecount();
  framecount_ = value;
  // @@protoc_insertion_point(field_set:nsm.InputState.framecount)
}

// -------------------------------------------------------------------

// PeerInputData

// required int32 counter = 1;
inline bool PeerInputData::has_counter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PeerInputData::set_has_counter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PeerInputData::clear_has_counter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PeerInputData::clear_counter() {
  counter_ = 0;
  clear_has_counter();
}
inline ::google::protobuf::int32 PeerInputData::counter() const {
  // @@protoc_insertion_point(field_get:nsm.PeerInputData.counter)
  return counter_;
}
inline void PeerInputData::set_counter(::google::protobuf::int32 value) {
  set_has_counter();
  counter_ = value;
  // @@protoc_insertion_point(field_set:nsm.PeerInputData.counter)
}

// required .nsm.Attotime time = 2;
inline bool PeerInputData::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PeerInputData::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PeerInputData::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PeerInputData::clear_time() {
  if (time_ != NULL) time_->::nsm::Attotime::Clear();
  clear_has_time();
}
inline const ::nsm::Attotime& PeerInputData::time() const {
  // @@protoc_insertion_point(field_get:nsm.PeerInputData.time)
  return time_ != NULL ? *time_ : *default_instance_->time_;
}
inline ::nsm::Attotime* PeerInputData::mutable_time() {
  set_has_time();
  if (time_ == NULL) time_ = new ::nsm::Attotime;
  // @@protoc_insertion_point(field_mutable:nsm.PeerInputData.time)
  return time_;
}
inline ::nsm::Attotime* PeerInputData::release_time() {
  clear_has_time();
  ::nsm::Attotime* temp = time_;
  time_ = NULL;
  return temp;
}
inline void PeerInputData::set_allocated_time(::nsm::Attotime* time) {
  delete time_;
  time_ = time;
  if (time) {
    set_has_time();
  } else {
    clear_has_time();
  }
  // @@protoc_insertion_point(field_set_allocated:nsm.PeerInputData.time)
}

// required .nsm.PeerInputData.PeerInputType inputType = 3;
inline bool PeerInputData::has_inputtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PeerInputData::set_has_inputtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PeerInputData::clear_has_inputtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PeerInputData::clear_inputtype() {
  inputtype_ = 0;
  clear_has_inputtype();
}
inline ::nsm::PeerInputData_PeerInputType PeerInputData::inputtype() const {
  // @@protoc_insertion_point(field_get:nsm.PeerInputData.inputType)
  return static_cast< ::nsm::PeerInputData_PeerInputType >(inputtype_);
}
inline void PeerInputData::set_inputtype(::nsm::PeerInputData_PeerInputType value) {
  assert(::nsm::PeerInputData_PeerInputType_IsValid(value));
  set_has_inputtype();
  inputtype_ = value;
  // @@protoc_insertion_point(field_set:nsm.PeerInputData.inputType)
}

// optional .nsm.InputState inputState = 4;
inline bool PeerInputData::has_inputstate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PeerInputData::set_has_inputstate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PeerInputData::clear_has_inputstate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PeerInputData::clear_inputstate() {
  if (inputstate_ != NULL) inputstate_->::nsm::InputState::Clear();
  clear_has_inputstate();
}
inline const ::nsm::InputState& PeerInputData::inputstate() const {
  // @@protoc_insertion_point(field_get:nsm.PeerInputData.inputState)
  return inputstate_ != NULL ? *inputstate_ : *default_instance_->inputstate_;
}
inline ::nsm::InputState* PeerInputData::mutable_inputstate() {
  set_has_inputstate();
  if (inputstate_ == NULL) inputstate_ = new ::nsm::InputState;
  // @@protoc_insertion_point(field_mutable:nsm.PeerInputData.inputState)
  return inputstate_;
}
inline ::nsm::InputState* PeerInputData::release_inputstate() {
  clear_has_inputstate();
  ::nsm::InputState* temp = inputstate_;
  inputstate_ = NULL;
  return temp;
}
inline void PeerInputData::set_allocated_inputstate(::nsm::InputState* inputstate) {
  delete inputstate_;
  inputstate_ = inputstate;
  if (inputstate) {
    set_has_inputstate();
  } else {
    clear_has_inputstate();
  }
  // @@protoc_insertion_point(field_set_allocated:nsm.PeerInputData.inputState)
}

// optional bytes inputBuffer = 5;
inline bool PeerInputData::has_inputbuffer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PeerInputData::set_has_inputbuffer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PeerInputData::clear_has_inputbuffer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PeerInputData::clear_inputbuffer() {
  if (inputbuffer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inputbuffer_->clear();
  }
  clear_has_inputbuffer();
}
inline const ::std::string& PeerInputData::inputbuffer() const {
  // @@protoc_insertion_point(field_get:nsm.PeerInputData.inputBuffer)
  return *inputbuffer_;
}
inline void PeerInputData::set_inputbuffer(const ::std::string& value) {
  set_has_inputbuffer();
  if (inputbuffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inputbuffer_ = new ::std::string;
  }
  inputbuffer_->assign(value);
  // @@protoc_insertion_point(field_set:nsm.PeerInputData.inputBuffer)
}
inline void PeerInputData::set_inputbuffer(const char* value) {
  set_has_inputbuffer();
  if (inputbuffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inputbuffer_ = new ::std::string;
  }
  inputbuffer_->assign(value);
  // @@protoc_insertion_point(field_set_char:nsm.PeerInputData.inputBuffer)
}
inline void PeerInputData::set_inputbuffer(const void* value, size_t size) {
  set_has_inputbuffer();
  if (inputbuffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inputbuffer_ = new ::std::string;
  }
  inputbuffer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nsm.PeerInputData.inputBuffer)
}
inline ::std::string* PeerInputData::mutable_inputbuffer() {
  set_has_inputbuffer();
  if (inputbuffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    inputbuffer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nsm.PeerInputData.inputBuffer)
  return inputbuffer_;
}
inline ::std::string* PeerInputData::release_inputbuffer() {
  clear_has_inputbuffer();
  if (inputbuffer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = inputbuffer_;
    inputbuffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PeerInputData::set_allocated_inputbuffer(::std::string* inputbuffer) {
  if (inputbuffer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete inputbuffer_;
  }
  if (inputbuffer) {
    set_has_inputbuffer();
    inputbuffer_ = inputbuffer;
  } else {
    clear_has_inputbuffer();
    inputbuffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nsm.PeerInputData.inputBuffer)
}

// required int32 generation = 6;
inline bool PeerInputData::has_generation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PeerInputData::set_has_generation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PeerInputData::clear_has_generation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PeerInputData::clear_generation() {
  generation_ = 0;
  clear_has_generation();
}
inline ::google::protobuf::int32 PeerInputData::generation() const {
  // @@protoc_insertion_point(field_get:nsm.PeerInputData.generation)
  return generation_;
}
inline void PeerInputData::set_generation(::google::protobuf::int32 value) {
  set_has_generation();
  generation_ = value;
  // @@protoc_insertion_point(field_set:nsm.PeerInputData.generation)
}

// -------------------------------------------------------------------

// PeerInputDataList

// repeated .nsm.PeerInputData input_data = 1;
inline int PeerInputDataList::input_data_size() const {
  return input_data_.size();
}
inline void PeerInputDataList::clear_input_data() {
  input_data_.Clear();
}
inline const ::nsm::PeerInputData& PeerInputDataList::input_data(int index) const {
  // @@protoc_insertion_point(field_get:nsm.PeerInputDataList.input_data)
  return input_data_.Get(index);
}
inline ::nsm::PeerInputData* PeerInputDataList::mutable_input_data(int index) {
  // @@protoc_insertion_point(field_mutable:nsm.PeerInputDataList.input_data)
  return input_data_.Mutable(index);
}
inline ::nsm::PeerInputData* PeerInputDataList::add_input_data() {
  // @@protoc_insertion_point(field_add:nsm.PeerInputDataList.input_data)
  return input_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputData >&
PeerInputDataList::input_data() const {
  // @@protoc_insertion_point(field_list:nsm.PeerInputDataList.input_data)
  return input_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputData >*
PeerInputDataList::mutable_input_data() {
  // @@protoc_insertion_point(field_mutable_list:nsm.PeerInputDataList.input_data)
  return &input_data_;
}

// required int32 peer_id = 2;
inline bool PeerInputDataList::has_peer_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PeerInputDataList::set_has_peer_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PeerInputDataList::clear_has_peer_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PeerInputDataList::clear_peer_id() {
  peer_id_ = 0;
  clear_has_peer_id();
}
inline ::google::protobuf::int32 PeerInputDataList::peer_id() const {
  // @@protoc_insertion_point(field_get:nsm.PeerInputDataList.peer_id)
  return peer_id_;
}
inline void PeerInputDataList::set_peer_id(::google::protobuf::int32 value) {
  set_has_peer_id();
  peer_id_ = value;
  // @@protoc_insertion_point(field_set:nsm.PeerInputDataList.peer_id)
}

// -------------------------------------------------------------------

// InitialSync

// repeated uint32 checksum = 1;
inline int InitialSync::checksum_size() const {
  return checksum_.size();
}
inline void InitialSync::clear_checksum() {
  checksum_.Clear();
}
inline ::google::protobuf::uint32 InitialSync::checksum(int index) const {
  // @@protoc_insertion_point(field_get:nsm.InitialSync.checksum)
  return checksum_.Get(index);
}
inline void InitialSync::set_checksum(int index, ::google::protobuf::uint32 value) {
  checksum_.Set(index, value);
  // @@protoc_insertion_point(field_set:nsm.InitialSync.checksum)
}
inline void InitialSync::add_checksum(::google::protobuf::uint32 value) {
  checksum_.Add(value);
  // @@protoc_insertion_point(field_add:nsm.InitialSync.checksum)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
InitialSync::checksum() const {
  // @@protoc_insertion_point(field_list:nsm.InitialSync.checksum)
  return checksum_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
InitialSync::mutable_checksum() {
  // @@protoc_insertion_point(field_mutable_list:nsm.InitialSync.checksum)
  return &checksum_;
}

// repeated bytes initial_block = 2;
inline int InitialSync::initial_block_size() const {
  return initial_block_.size();
}
inline void InitialSync::clear_initial_block() {
  initial_block_.Clear();
}
inline const ::std::string& InitialSync::initial_block(int index) const {
  // @@protoc_insertion_point(field_get:nsm.InitialSync.initial_block)
  return initial_block_.Get(index);
}
inline ::std::string* InitialSync::mutable_initial_block(int index) {
  // @@protoc_insertion_point(field_mutable:nsm.InitialSync.initial_block)
  return initial_block_.Mutable(index);
}
inline void InitialSync::set_initial_block(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nsm.InitialSync.initial_block)
  initial_block_.Mutable(index)->assign(value);
}
inline void InitialSync::set_initial_block(int index, const char* value) {
  initial_block_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nsm.InitialSync.initial_block)
}
inline void InitialSync::set_initial_block(int index, const void* value, size_t size) {
  initial_block_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nsm.InitialSync.initial_block)
}
inline ::std::string* InitialSync::add_initial_block() {
  return initial_block_.Add();
}
inline void InitialSync::add_initial_block(const ::std::string& value) {
  initial_block_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nsm.InitialSync.initial_block)
}
inline void InitialSync::add_initial_block(const char* value) {
  initial_block_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nsm.InitialSync.initial_block)
}
inline void InitialSync::add_initial_block(const void* value, size_t size) {
  initial_block_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nsm.InitialSync.initial_block)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InitialSync::initial_block() const {
  // @@protoc_insertion_point(field_list:nsm.InitialSync.initial_block)
  return initial_block_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InitialSync::mutable_initial_block() {
  // @@protoc_insertion_point(field_mutable_list:nsm.InitialSync.initial_block)
  return &initial_block_;
}

// repeated .nsm.PeerInputDataList peer_data = 3;
inline int InitialSync::peer_data_size() const {
  return peer_data_.size();
}
inline void InitialSync::clear_peer_data() {
  peer_data_.Clear();
}
inline const ::nsm::PeerInputDataList& InitialSync::peer_data(int index) const {
  // @@protoc_insertion_point(field_get:nsm.InitialSync.peer_data)
  return peer_data_.Get(index);
}
inline ::nsm::PeerInputDataList* InitialSync::mutable_peer_data(int index) {
  // @@protoc_insertion_point(field_mutable:nsm.InitialSync.peer_data)
  return peer_data_.Mutable(index);
}
inline ::nsm::PeerInputDataList* InitialSync::add_peer_data() {
  // @@protoc_insertion_point(field_add:nsm.InitialSync.peer_data)
  return peer_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputDataList >&
InitialSync::peer_data() const {
  // @@protoc_insertion_point(field_list:nsm.InitialSync.peer_data)
  return peer_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::nsm::PeerInputDataList >*
InitialSync::mutable_peer_data() {
  // @@protoc_insertion_point(field_mutable_list:nsm.InitialSync.peer_data)
  return &peer_data_;
}

// repeated bytes nvram = 4;
inline int InitialSync::nvram_size() const {
  return nvram_.size();
}
inline void InitialSync::clear_nvram() {
  nvram_.Clear();
}
inline const ::std::string& InitialSync::nvram(int index) const {
  // @@protoc_insertion_point(field_get:nsm.InitialSync.nvram)
  return nvram_.Get(index);
}
inline ::std::string* InitialSync::mutable_nvram(int index) {
  // @@protoc_insertion_point(field_mutable:nsm.InitialSync.nvram)
  return nvram_.Mutable(index);
}
inline void InitialSync::set_nvram(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nsm.InitialSync.nvram)
  nvram_.Mutable(index)->assign(value);
}
inline void InitialSync::set_nvram(int index, const char* value) {
  nvram_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nsm.InitialSync.nvram)
}
inline void InitialSync::set_nvram(int index, const void* value, size_t size) {
  nvram_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nsm.InitialSync.nvram)
}
inline ::std::string* InitialSync::add_nvram() {
  return nvram_.Add();
}
inline void InitialSync::add_nvram(const ::std::string& value) {
  nvram_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nsm.InitialSync.nvram)
}
inline void InitialSync::add_nvram(const char* value) {
  nvram_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nsm.InitialSync.nvram)
}
inline void InitialSync::add_nvram(const void* value, size_t size) {
  nvram_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nsm.InitialSync.nvram)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
InitialSync::nvram() const {
  // @@protoc_insertion_point(field_list:nsm.InitialSync.nvram)
  return nvram_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
InitialSync::mutable_nvram() {
  // @@protoc_insertion_point(field_mutable_list:nsm.InitialSync.nvram)
  return &nvram_;
}

// required int32 generation = 5;
inline bool InitialSync::has_generation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InitialSync::set_has_generation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InitialSync::clear_has_generation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InitialSync::clear_generation() {
  generation_ = 0;
  clear_has_generation();
}
inline ::google::protobuf::int32 InitialSync::generation() const {
  // @@protoc_insertion_point(field_get:nsm.InitialSync.generation)
  return generation_;
}
inline void InitialSync::set_generation(::google::protobuf::int32 value) {
  set_has_generation();
  generation_ = value;
  // @@protoc_insertion_point(field_set:nsm.InitialSync.generation)
}

// required .nsm.Attotime global_time = 6;
inline bool InitialSync::has_global_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InitialSync::set_has_global_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InitialSync::clear_has_global_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InitialSync::clear_global_time() {
  if (global_time_ != NULL) global_time_->::nsm::Attotime::Clear();
  clear_has_global_time();
}
inline const ::nsm::Attotime& InitialSync::global_time() const {
  // @@protoc_insertion_point(field_get:nsm.InitialSync.global_time)
  return global_time_ != NULL ? *global_time_ : *default_instance_->global_time_;
}
inline ::nsm::Attotime* InitialSync::mutable_global_time() {
  set_has_global_time();
  if (global_time_ == NULL) global_time_ = new ::nsm::Attotime;
  // @@protoc_insertion_point(field_mutable:nsm.InitialSync.global_time)
  return global_time_;
}
inline ::nsm::Attotime* InitialSync::release_global_time() {
  clear_has_global_time();
  ::nsm::Attotime* temp = global_time_;
  global_time_ = NULL;
  return temp;
}
inline void InitialSync::set_allocated_global_time(::nsm::Attotime* global_time) {
  delete global_time_;
  global_time_ = global_time;
  if (global_time) {
    set_has_global_time();
  } else {
    clear_has_global_time();
  }
  // @@protoc_insertion_point(field_set_allocated:nsm.InitialSync.global_time)
}

// -------------------------------------------------------------------

// SyncBlock

// required int32 index = 1;
inline bool SyncBlock::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncBlock::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncBlock::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncBlock::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 SyncBlock::index() const {
  // @@protoc_insertion_point(field_get:nsm.SyncBlock.index)
  return index_;
}
inline void SyncBlock::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:nsm.SyncBlock.index)
}

// required bytes data = 2;
inline bool SyncBlock::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncBlock::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncBlock::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncBlock::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& SyncBlock::data() const {
  // @@protoc_insertion_point(field_get:nsm.SyncBlock.data)
  return *data_;
}
inline void SyncBlock::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:nsm.SyncBlock.data)
}
inline void SyncBlock::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:nsm.SyncBlock.data)
}
inline void SyncBlock::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nsm.SyncBlock.data)
}
inline ::std::string* SyncBlock::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:nsm.SyncBlock.data)
  return data_;
}
inline ::std::string* SyncBlock::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SyncBlock::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:nsm.SyncBlock.data)
}

// -------------------------------------------------------------------

// Sync

// repeated .nsm.SyncBlock block = 1;
inline int Sync::block_size() const {
  return block_.size();
}
inline void Sync::clear_block() {
  block_.Clear();
}
inline const ::nsm::SyncBlock& Sync::block(int index) const {
  // @@protoc_insertion_point(field_get:nsm.Sync.block)
  return block_.Get(index);
}
inline ::nsm::SyncBlock* Sync::mutable_block(int index) {
  // @@protoc_insertion_point(field_mutable:nsm.Sync.block)
  return block_.Mutable(index);
}
inline ::nsm::SyncBlock* Sync::add_block() {
  // @@protoc_insertion_point(field_add:nsm.Sync.block)
  return block_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::nsm::SyncBlock >&
Sync::block() const {
  // @@protoc_insertion_point(field_list:nsm.Sync.block)
  return block_;
}
inline ::google::protobuf::RepeatedPtrField< ::nsm::SyncBlock >*
Sync::mutable_block() {
  // @@protoc_insertion_point(field_mutable_list:nsm.Sync.block)
  return &block_;
}

// required .nsm.Attotime global_time = 2;
inline bool Sync::has_global_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sync::set_has_global_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Sync::clear_has_global_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Sync::clear_global_time() {
  if (global_time_ != NULL) global_time_->::nsm::Attotime::Clear();
  clear_has_global_time();
}
inline const ::nsm::Attotime& Sync::global_time() const {
  // @@protoc_insertion_point(field_get:nsm.Sync.global_time)
  return global_time_ != NULL ? *global_time_ : *default_instance_->global_time_;
}
inline ::nsm::Attotime* Sync::mutable_global_time() {
  set_has_global_time();
  if (global_time_ == NULL) global_time_ = new ::nsm::Attotime;
  // @@protoc_insertion_point(field_mutable:nsm.Sync.global_time)
  return global_time_;
}
inline ::nsm::Attotime* Sync::release_global_time() {
  clear_has_global_time();
  ::nsm::Attotime* temp = global_time_;
  global_time_ = NULL;
  return temp;
}
inline void Sync::set_allocated_global_time(::nsm::Attotime* global_time) {
  delete global_time_;
  global_time_ = global_time;
  if (global_time) {
    set_has_global_time();
  } else {
    clear_has_global_time();
  }
  // @@protoc_insertion_point(field_set_allocated:nsm.Sync.global_time)
}

// required int32 generation = 3;
inline bool Sync::has_generation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Sync::set_has_generation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Sync::clear_has_generation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Sync::clear_generation() {
  generation_ = 0;
  clear_has_generation();
}
inline ::google::protobuf::int32 Sync::generation() const {
  // @@protoc_insertion_point(field_get:nsm.Sync.generation)
  return generation_;
}
inline void Sync::set_generation(::google::protobuf::int32 value) {
  set_has_generation();
  generation_ = value;
  // @@protoc_insertion_point(field_set:nsm.Sync.generation)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace nsm

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::nsm::PeerInputData_PeerInputType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nsm::PeerInputData_PeerInputType>() {
  return ::nsm::PeerInputData_PeerInputType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_nsm_2eproto__INCLUDED
